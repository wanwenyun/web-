- [计算机网络体系](#计算机网络体系)
- [TCP协议](#tcp协议)
  - [三次握手](#三次握手)
    - [为什么要三次握手？](#为什么要三次握手)
    - [三次握手过程中可以携带数据吗？](#三次握手过程中可以携带数据吗)
    - [如果第三次握手丢失了，客户端服务端会如何处理 - 重传机制](#如果第三次握手丢失了客户端服务端会如何处理---重传机制)
    - [SYN 洪泛攻击](#syn-洪泛攻击)
  - [四次挥手](#四次挥手)
    - [等待2MSL的意义](#等待2msl的意义)
    - [为什么是4次挥手](#为什么是4次挥手)
  - [TCP重传机制，滑动窗口，流量控制，拥塞控制](#tcp重传机制滑动窗口流量控制拥塞控制)
    - [重传机制](#重传机制)
      - [超时重传](#超时重传)
      - [快速重传](#快速重传)
      - [SACK 方法](#sack-方法)
    - [滑动窗口](#滑动窗口)
    - [流量控制](#流量控制)
    - [拥塞控制](#拥塞控制)
  - [单域名连接限制](#单域名连接限制)
  - [Tcp和Udp的区别](#tcp和udp的区别)
- [DNS解析，域名解析](#dns解析域名解析)



# 计算机网络体系
计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层）。

<img src="./picture/network/pic2.png"/>

1. 七层模型（OSI模型）：
   - 物理层：这是最底层，它定义了传输数据所需的物理介质，如电缆、光纤等。
   - 数据链路层：负责在直接相连的节点之间传输数据，通过物理地址（MAC地址）来寻址和控制传输错误。
   - 网络层：处理网络地址和路由选择，以确保数据包能够从源节点到目标节点进行正确的路由。
   - 传输层：提供端到端的数据传输服务，包括可靠性保证、流量控制和拥塞控制。常见的协议有TCP（传输控制协议）和UDP（用户数据报协议）。
   - 会话层：建立、管理和终止会话（通信会话）。
   - 表示层：负责数据的加密、压缩和格式转换，以确保不同系统间的数据能够正确解释和处理。
   - 应用层：最高层，提供用户与网络应用程序之间的接口，包括各种应用协议，如HTTP、FTP、SMTP等。

2. 五层模型（TCP/IP模型）：
   - 物理层：与七层模型中的物理层相同，负责传输原始比特流。
   - 数据链路层：与七层模型中的数据链路层相同，负责在直接相连的节点之间传输数据。
   - 网络层：包括IP（Internet协议）和路由功能，用于处理数据包的寻址和路由。
   - 传输层：与七层模型中的传输层相同，提供端到端的数据传输服务，包括TCP和UDP等协议。
   - 应用层：合并了七层模型中的会话层、表示层和应用层，提供各种应用协议和服务。


# TCP协议
> [参考链接](https://segmentfault.com/a/1190000039165592)

tcp协议是**传输层**协议。TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。

**三次握手，建立连接**。

**四次挥手，关闭连接**。

http/1.1默认使用长连接，Connection:keep-alive，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。

## 三次握手
三次握手，建立连接过程如下：

<img src="./picture/network/tcp1.png" width= 70%/>

图中字符的含义：
* SYN：连接请求/接收 报文段
* seq：发送的第一个字节的序号
* ACK：确认报文段
* ack：确认号。希望收到的下一个数据的第一个字节的序号

过程如下：
1. **第一次握手**：客户端向服务端发送一个 `SYN` 报文（`SYN = 1`），并指明客户端的初始化序列号 `ISN(x)`，即图中的 `seq = x`，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 `SYN_Send` 状态。
   >`SYN-SENT` ：在发送连接请求后等待匹配的连接请求
2. **第二次握手**：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（`SYN = 1`），并且指定自己的初始化序列号 `ISN(y)`，即图中的 `seq = y`。同时会把客户端的 `ISN + 1` 作为确认号 `ack` 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 `x + 1`，此时服务器处于 `SYN_REVD` 的状态。
   > `SYN-RECEIVED`：在收到和发送一个连接请求后等待对连接请求的确认
3. **第三次握手**：客户端收到服务器端响应的 SYN 报文之后，会发送一个 `ACK` 报文，也是一样把服务器的 `ISN + 1` 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 `y + 1`，并指明此时客户端的序列号 `seq = x + 1`（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 `Establised` 状态。
   >`ESTABLISHED`：代表一个打开的连接，数据可以传送给用户
4. 服务器收到 ACK 报文之后，也处于 Establised 状态，至此，双方建立起了 TCP 连接。可以进行数据传输了
   
### 为什么要三次握手？
三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是**双方确认自己与对方的发送与接收是正常的**。
* 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常
* 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：
    * 客户端确认了：自己发送、接收正常，对方发送、接收正常；
    * 服务器确认了：对方发送正常，自己接收正常
* 第三次握手（客户端发送 ACK 报文给服务器）：
    * 客户端确认了：自己发送、接收正常，对方发送、接收正常；
    * 服务器确认了：自己发送、接收正常，对方发送、接收正常

### 三次握手过程中可以携带数据吗？
第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手绝对不可以携带数据**。

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后**疯狂重复发 SYN 报文**的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。

>简单的记忆就是，请求连接/接收 即 SYN = 1 的时候不能携带数据

### 如果第三次握手丢失了，客户端服务端会如何处理 - 重传机制
服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即**第三次握手丢失**。那么服务器就会进行首次**重传**，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…


### SYN 洪泛攻击
SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内**伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN**。对于服务端而言，会产生两个危险的后果:

* 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。
* 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。



## 四次挥手
四次挥手，关闭连接过程如下：

<img src="./picture/network/tcp4.png"/>

<details>
<summary>更官方的解释</summary>

<img src="./picture/network/tcp2.png" width= 70%/>

上图中符号的意思：
* FIN ：连接终止位
* seq：发送的第一个字节的序号
* ACK：确认报文段
* ack：确认号。希望收到的下一个数据的第一个字节的序号

<!-- 刚开始双方都处于ESTABLISHED 状态，假设是客户端先发起关闭请求。过程如下：

1. **第一次挥手**：客户端发送一个 `FIN` 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并停止再发送数据，主动关闭 TCP 连接。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。
    > `FIN-WAIT-1` - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
2. **第二次挥手**：服务端收到 FIN 之后，会发送 `ACK` 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。
   > `CLOSE-WAIT` - 等待从本地用户发来的连接中断请求；
   
   此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的**连接释放报文段**。
   > `FIN-WAIT-2` - 从远程TCP等待连接中断请求；
3. **第三次挥手**：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。
    > `LAST-ACK` - 等待原来发向远程TCP的连接中断请求的确认；
4. **第四次挥手**：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 **TIME_WAIT** （时间等待）状态。
    > `TIME-WAIT` - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；

    PS:注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 **2 个 MSL**(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。 -->

- **第一次挥手**： 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。
- **第二次挥手**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，**此时表明客户端到服务端的连接已经释放，不再接收客户端发的数**据了。但是因为 TCP 连接是**双向的**，所以**服务端仍旧可以发送数据给客户端**。
- **第三次挥手**：**表式服务端也想断开链接了**。服务端如果此时还有**没发完的数据**会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。
- **第四次挥手**： 客户端收到释放请求后，向服务端发送**确认应答**，此时客户端进入 TIME-WAIT 状态。该状态会持续 **2MSL**（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。挥手结束

</details>



### 等待2MSL的意义
如果不等待会怎样？

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。

那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?
* 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
* 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达
  
这就是等待 2MSL 的意义。

### 为什么是4次挥手
任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。

## TCP重传机制，滑动窗口，流量控制，拥塞控制
> https://xiaolincoding.com/network/3_tcp/tcp_feature.html
### 重传机制
TCP 实现可靠传输的方式之一，是通过序列号与确认应答。
在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，**表示已收到消息**。
一旦数据在传输过程中丢失了呢？所以 TCP 针对数据包丢失的情况，会用重传机制解决。

常见的重传机制有一下几种：

- 超时重传
- 快速重传
- SACK
- D-SACK

#### 超时重传
在发送数据时，设定一个**定时器**，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据。

TCP 会在以下两种情况发生超时重传：

- 数据包丢失
- 确认应答丢失

超时重传时间以 `RTO` 表示。**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**。且每**当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍**。

带来问题：超时触发重传存在的问题是，超时周期可能相对较长。
解决办法：快速重传

#### 快速重传
它**不以时间为驱动，而是以数据驱动重传**。
快速重传的工作方式是当收到**三个相同**的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

<img src='./picture/network/tcpTimeout1.png' />

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
- 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

问题：如果多个保文丢失，不知道该重传哪些 TCP 报文。

为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法

#### SACK 方法
SACK（ Selective Acknowledgment）， 选择性确认。

这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。

### 滑动窗口

**引入原因**：每发送一个数据都需要进行确认应答，收到了再发送下一个，效率比较低。**在窗口大小限制范围内，可以无需等待上一个数据包应答，就可以继续发送下一个数据包**

**窗口大小**：就是指**无需等待确认应答，而可以继续发送数据的最大值**。
- tcp头里的字段window
  - **接收方**通过这个字段告诉发送方自己还有多少缓冲区可以接收数据，发送方就可以根据接收方的处理来发送数据，以免导致接收方处理不过来，因此**窗口的大小是由接收方决定的**
- 接收方和发送方的窗口
  - 接收方和发送方的窗口大小基本相等，因为发送方的窗口大小取决于接收方，当接收方处理能力快，窗口变大，通过tcp报文中的window字段告诉接收方，若传输过程中出现了延迟，所以这时两个窗口大小不一致

<img src='./picture/network/tcpTimeout2.png' />

### 流量控制
发送方不能无脑的发数据给接收方，要考虑接收方处理能力。

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

流量控制是基于**滑动窗口**实现的，tcp通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。


### 拥塞控制

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。

就有了拥塞控制，控制的**目的就是避免「发送方」的数据填满整个网络**。

**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。其变化规律如下：
- 只要网络中没有出现拥塞，cwnd 就会增大；
  - 只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞**。
- 但网络中出现了拥塞，cwnd 就减少；

拥塞控制主要是四个算法：慢启动，拥塞避免，拥塞发生，快速恢复

- **慢启动**：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。上限为`ssthresh`，65535字节。
  <img src='./picture/network/cwnd1.png' />
  - 当 cwnd < ssthresh 时，使用慢启动算法。
  - 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。
- **拥塞避免**：每当收到一个 ACK 时，cwnd 增加 1/cwnd。线性增长。
  <img src='./picture/network/cwnd2.png' />
  拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长。

  就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

  当触发了重传机制，也就进入了「拥塞发生算法」。

- **拥塞发生**：
  - 超时重传
    - ssthreshold设为cwnd/2
    - cwnd设为1
    - 即一旦发生超时重传就重新进入慢启动
  - 快速重传
    - 当接收方发现丢了一个中间包时，会发送三次丢失包的ack，发送方收到- 后就会快速重传丢失的包
    - tcp认为这时候拥塞并不严重，只丢了一小部分包，于是
      - cwnd = cwnd/2
      - ssthreshold变为cwnd
    - 然后进入快速恢复算法
- **快速恢复**：
  - cwnd = ssthresold+3
  - 重传丢失的数据包
  - 如果再收到重复的ack，那么cwnd+1
  - 收到新的ack后，cwnd变为ssthreshold，然后进入拥塞避免算法

## 单域名连接限制

目前谷歌浏览器中对于同一个域名，默认允许同时建立 **6个 TCP 持久连接**。（不同浏览器限制不同）


## Tcp和Udp的区别
HTTP/3.0是基于UDP协议实现的
Tcp和Udp主要区别如下：
1. **连接性**：TCP是面向连接的协议，而UDP是面向无连接的协议。TCP在通信之前需要先建立一个连接（3次握手），而UDP则直接发送数据包。
2. **可靠性**：TCP提供可靠的数据传输，它使用序号、确认和重传机制来确保数据的可靠性。UDP不提供可靠性保证，它只是简单地发送数据包，不保证数据的到达和顺序。
3. **速度和效率**：由于TCP提供可靠性保证，它需要进行连接的建立、序号的维护和确认的处理等操作，这些额外的开销会影响传输速度。相比之下，UDP没有这些开销，所以通常比TCP更快。
4. **数据包的大小**：TCP对传输的数据进行分段并进行重新组装，可以处理较大的数据量。而UDP的数据包大小限制较小，通常被限制在64KB以内。
5. **应用场景**：由于TCP具有可靠性和连接性，适用于对数据传输要求高的应用，如文件传输、电子邮件和网页浏览等。而UDP适用于实时性要求高、数据丢失可容忍的应用，如在线游戏、流媒体和实时视频通话等。


# DNS解析，域名解析
<img src="./picture/network/dns.png" width=60%/>

- 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
- 本地DNS服务器将返回结果保存在**缓存**中，便于下次使用
- 本地DNS服务器将返回结果返回给浏览器