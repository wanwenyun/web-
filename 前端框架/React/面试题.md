- [React render方法的原理？在什么时候会被触发？](#react-render方法的原理在什么时候会被触发)
- [如何理解render阶段、commit阶段？](#如何理解render阶段commit阶段)


### React render方法的原理？在什么时候会被触发？

首先，render函数在react中有两种形式：

在类组件中，指的是`render`方法：

```js
class Foo extends React.Component {
    render() {
        return <h1> Foo </h1>;
    }
}
```

在函数组件中，指的是函数组件本身：

```js
function Foo() {
    return <h1> Foo </h1>;
}
```

render的执行时机主要分成了两部分：

1. 类组件调用 `setState` 修改状态，并重渲染
   
   ```js
   class App extends React.Component {
     state = { name: "App" };
     render() {
       return (
         <div className="App">
           <Foo />
           <button onClick={() => this.setState({ name: "App" })}>
             Change name
           </button>
         </div>
       );
     }
   }   

   function Foo() {
     console.log("Foo render");   

     return (
       <div>
         <h1> Foo </h1>
       </div>
     );
   }
   ```

   只要点击了 App 组件内的 Change name 按钮，不管 Foo 具体实现是什么，**都会被重新render渲染**
2. 函数组件通过`useState hook`修改状态，并重渲染

   ```js
   function App(){
       const [name,setName] = useState('App')
   
       return (
           <div className="App">
               <Foo />
               <button onClick={() => setName("aaa")}>
                   { name }
               </button>
         </div>
       )
   }
   
   function Foo() {
     console.log("Foo render");
   
     return (
       <div>
         <h1> Foo </h1>
       </div>
     );
   }
   ```

   使用useState来更新状态的时候，只有**首次**会触发Foo render，后面并不会导致Foo render

在React 中，**类组件**只要执行了 `setState` 方法，就一定会触发 render 函数执行，

**函数组件**使用`useState`更改状态不一定导致重新render

组件的props 改变了，不一定触发 render 函数的执行，但是如果 props 的值来自于父组件或者祖先组件的 state。在这种情况下，父组件或者祖先组件的 state 发生了改变，就会导致子组件的重新渲染

### 如何理解render阶段、commit阶段？

**render阶段**

- 在render阶段，React将**更新**应用于通过`setState或render`方法触发的组件，并确定需要在用户屏幕上做哪些更新--哪些节点需要插入，更新或删除，哪些组件需要调用其生命周期方法。
- 最终的这些更新信息被保存在一个叫`effect list`的`fiber` 节点树上
- 当然，在首次渲染时，React不需要产生任何更新信息，而是会给每个从render方法返回的element生成一个fiber节点，最终生成一个fiber节点树， 后续的更新也是复用了这棵fiber树。

**commit阶段**
在这个阶段时，React内部会有2个`fiber树`和一个`list`：

  1. `current fiber tree`: 表示`显示内容`对应Fiber树。后续的更新也是复用了这棵fiber树。
  2. `workInProgress fiber tree`: 表示`正在内存构建`的Fiber树。所有的更新计算工作都workInProgress tree的fiber上执行。
  3. `effect list`: 是workInProgress fiber tree 的子树，它的作用是串联了标记具有更新的节点

Commit阶段会遍历`effect list`，把所有更新都commit到`DOM树`上。具体过程如下：

1. 首先会有一个pre-commit阶段，主要是`getSnapshotBeforeUpdate`方法，可以获取当前DO快照（snap）
2. 然后给需要卸载的组件执行componentWillUnmoun法
3. 接着会把current fiber tree 替workInProgress fiber tree
4. 最后执行DOM的插入、更新和删除，给更新的组件执行componentDidUpdate，给插入的组件执行componentDidMount
   
