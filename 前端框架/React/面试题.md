- [React render方法的原理？在什么时候会被触发？](#react-render方法的原理在什么时候会被触发)
- [如何理解render阶段、commit阶段？](#如何理解render阶段commit阶段)
- [如何理解react框架V16的心智模式](#如何理解react框架v16的心智模式)
- [为什么useState会引起react组件重渲染？](#为什么usestate会引起react组件重渲染)
- [React如何进行性能优化？](#react如何进行性能优化)
- [React V15, V16, V18的之间的重大改变？](#react-v15-v16-v18的之间的重大改变)
- [RendertoString()是什么？](#rendertostring是什么)
- [React服务端渲染如何使用？原理是什么?](#react服务端渲染如何使用原理是什么)


### React render方法的原理？在什么时候会被触发？

首先，render函数在react中有两种形式：

在类组件中，指的是`render`方法：

```js
class Foo extends React.Component {
    render() {
        return <h1> Foo </h1>;
    }
}
```

在函数组件中，指的是函数组件本身：

```js
function Foo() {
    return <h1> Foo </h1>;
}
```

render的执行时机主要分成了两部分：

1. 类组件调用 `setState` 修改状态，并重渲染
   
   ```js
   class App extends React.Component {
     state = { name: "App" };
     render() {
       return (
         <div className="App">
           <Foo />
           <button onClick={() => this.setState({ name: "App" })}>
             Change name
           </button>
         </div>
       );
     }
   }   

   function Foo() {
     console.log("Foo render");   

     return (
       <div>
         <h1> Foo </h1>
       </div>
     );
   }
   ```

   只要点击了 App 组件内的 Change name 按钮，不管 Foo 具体实现是什么，**都会被重新render渲染**
2. 函数组件通过`useState hook`修改状态，并重渲染

   ```js
   function App(){
       const [name,setName] = useState('App')
   
       return (
           <div className="App">
               <Foo />
               <button onClick={() => setName("aaa")}>
                   { name }
               </button>
         </div>
       )
   }
   
   function Foo() {
     console.log("Foo render");
   
     return (
       <div>
         <h1> Foo </h1>
       </div>
     );
   }
   ```

   使用useState来更新状态的时候，只有**首次**会触发Foo render，后面并不会导致Foo render

在React 中，**类组件**只要执行了 `setState` 方法，就一定会触发 render 函数执行，

**函数组件**使用`useState`更改状态不一定导致重新render

组件的props 改变了，不一定触发 render 函数的执行，但是如果 props 的值来自于父组件或者祖先组件的 state。在这种情况下，父组件或者祖先组件的 state 发生了改变，就会导致子组件的重新渲染

### 如何理解render阶段、commit阶段？

**render阶段**

- 在render阶段，React将**更新**应用于通过`setState或render`方法触发的组件，并确定需要在用户屏幕上做哪些更新--哪些节点需要插入，更新或删除，哪些组件需要调用其生命周期方法。
- 最终的这些更新信息被保存在一个叫`effect list`的`fiber` 节点树上
- 当然，在首次渲染时，React不需要产生任何更新信息，而是会给每个从render方法返回的element生成一个fiber节点，最终生成一个fiber节点树， 后续的更新也是复用了这棵fiber树。

**commit阶段**
在这个阶段时，React内部会有2个`fiber树`和一个`list`：

  1. `current fiber tree`: 表示`显示内容`对应Fiber树。后续的更新也是复用了这棵fiber树。
  2. `workInProgress fiber tree`: 表示`正在内存构建`的Fiber树。所有的更新计算工作都workInProgress tree的fiber上执行。
  3. `effect list`: 是workInProgress fiber tree 的子树，它的作用是串联了标记具有更新的节点

Commit阶段会遍历`effect list`，把所有更新都commit到`DOM树`上。具体过程如下：

1. 首先会有一个pre-commit阶段，主要是`getSnapshotBeforeUpdate`方法，可以获取当前DO快照（snap）
2. 然后给需要卸载的组件执行componentWillUnmoun法
3. 接着会把current fiber tree 替workInProgress fiber tree
4. 最后执行DOM的插入、更新和删除，给更新的组件执行componentDidUpdate，给插入的组件执行componentDidMount
   
### 如何理解react框架V16的心智模式

React框架V16的心智模式是指其内部实现的一种思维方式，它是基于Fiber架构实现的。Fiber是ReactV16的核心算法，它改变了React更新组件的方式，使得React能够在更新过程中支持中断和恢复。因此，ReactV16的心智模式是基于Fiber架构实现的一种新思维方式，它具有以下特点：

1. 异步更新：ReactV16采用Fiber架构实现异步更新机制，可以在不阻塞主线程的情况下更新组件，提高了程序的性能。
2. 可中断：Fiber架构中的任务可以被中断，使得React可以灵活地控制任务的执行，提高了程序的响应速度。
3. 可恢复：Fiber架构支持任务的恢复，如果在执行任务时出现错误，React可以回滚到之前的状态，避免了出现不稳定的情况。
4. 优先级调度：ReactV16采用了优先级调度算法，可以根据任务的优先级来确定任务的执行顺序，提高了程序的响应速度和用户体验。
综上所述，React框架V16的心智模式是基于Fiber架构实现的一种新思维方式，它具有**异步更新、可中断、可恢复和优先级调度**等特点，可以提高程序的性能和用户体验。

### 为什么useState会引起react组件重渲染？

### React如何进行性能优化？

1. 列表项使用唯一 key
2. 使用代码拆分和懒加载（按需加载）
3. useMemo 返回虚拟 DOM
4. 避免渲染无用内容：当您更新一个组件时，React 将会重新渲染整个组件树。您可以使用 `React.memo` 或 `useCallback` 来避免渲染不必要的内容。

### React V15, V16, V18的之间的重大改变？

- **Fiber架构**：`React v16`引入了Fiber架构，这是一种新的渲染引擎，能够更好地控制渲染进程和响应时间，从而提高React应用的性能和稳定性。

- **Hooks**：`React v16`还引入了Hooks，这使得函数组件可以“勾入”React生命周期和状态的功能，从而消除了类组件和函数组件之间的许多不必要的差异。React v18也增加了一些新的Hooks，如useTransition和useSharedValue等。

- **Suspense**：`React v16`引入了Suspense组件，它可以在数据加载时暂停视图更新，从而使得React应用更加平稳的用户体验。

- **Concurrent Mode**：`React v18`引入了Concurrent Mode，它提高了React应用的性能和响应能力，能够更好地处理大型应用和慢速网络环境。

- **SSR改进**：`React v16和v18`都对服务器渲染进行了改进，使得React应用在服务器上运行更加高效和灵活。

### RendertoString()是什么？

### React服务端渲染如何使用？原理是什么?
