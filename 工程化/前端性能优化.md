- [性能指标](#性能指标)
- [性能优化分类及优化方案](#性能优化分类及优化方案)
  - [加载时性能优化](#加载时性能优化)
    - [DNS预解析](#dns预解析)
    - [使用HTTP2](#使用http2)
    - [减少HTTP请求数量，减少http请求大小](#减少http请求数量减少http请求大小)
      - [利用webpack压缩文件，文件合并，实现减少HTTP请求数量，减少http请求大小](#利用webpack压缩文件文件合并实现减少http请求数量减少http请求大小)
      - [避免重复请求](#避免重复请求)
    - [懒加载](#懒加载)
      - [实现](#实现)
      - [懒加载与预加载的区别](#懒加载与预加载的区别)
    - [服务器端渲染](#服务器端渲染)
    - [文件优化](#文件优化)
    - [静态资源使用CDN](#静态资源使用cdn)
    - [资源缓存](#资源缓存)
  - [运行时性能优化](#运行时性能优化)
    - [避免回流与重绘](#避免回流与重绘)
    - [节流和防抖，滚动事件性能优化](#节流和防抖滚动事件性能优化)
    - [使用 Web Workers](#使用-web-workers)
    - [写代码时的优化点](#写代码时的优化点)
- [Webpack](#webpack)

>https://alienzhou.github.io/fe-performance-journey/5-subresources/
>
>http://caibaojian.com/interview-map/frontend/performance.html
>https://juejin.cn/post/6941278592215515143#heading-35

# 性能指标

|指标名|含义|优秀数据|
|--|--|--|
|FP|页面首个像素点渲染时间|1000ms以内|
|FCP|页面首次内容渲染时间|1000ms以内|
|LCP|最大内容渲染时间|2000ms以内|
|FID|用户首次和网站进行交互到浏览器响应该事件的实际延时时间|100ms以内|
|TTI|首次可交互时间||
|CLS|页面累计布局偏移总和|0.1以内|

# 性能优化分类及优化方案
加载时优化，运行时优化

## 加载时性能优化
浏览器如果输入一个网址到展示页面到过程如下：
`DNS域名解析 -> 找到对应的IP地址 -> 然后进行TCP连接 -> 浏览器发送HTTP请求 -> 服务器接收请求 -> 服务器处理请求并返回HTTP报文 -> 以及浏览器接收并解析渲染页面`


这个过程中可以提升性能的优化的点：

- DNS解析优化，浏览器访问DNS的时间就可以缩短
- 使用HTTP2
- 减少HTTP请求数量，减少http请求大小
  - 压缩、合并文件，减小文件体积
  - 避免重复请求
- 懒加载
- 服务器端渲染
- 文件优化，图片和其他类型文件
- 静态资源使用CDN
- 资源缓存，不重复加载相同的资源

### DNS预解析
DNS预解析通过在用户点击链接之前预先解析与链接相关的域名，以加快网页加载速度。

DNS预解析的思想是，在用户点击链接**之前**，浏览器会尝试解析与链接相关的所有域名，并将解析结果存储在缓存中。这样，在用户实际点击链接时，浏览器就不需要再进行DNS解析，而是直接使用之前存储的IP地址，从而节省了时间。

在HTML中，可以使用`<link>`标签的`rel="dns-prefetch"`属性来指示浏览器预先解析特定的域名。例如：

```html
<link rel="dns-prefetch" href="//example.com">
```
用meta信息来告知浏览器, 当前页面要做DNS预解析:
`<meta http-equiv="x-dns-prefetch-control" content="on" />`

这将告诉浏览器在用户实际点击链接之前预先解析"example.com"域名。

### 使用HTTP2
HTTP2相对于HTTP1有这些优点：
1. **多路复用**
   - 帧是最小的数据单位，HTTP 报文会被拆分成一个个的**二进制形式的帧**。帧上面除了 HTTP 数据，还包含数据长度、流标识符、帧类型等信息。

   - 流是一个建立连接后的双向的虚拟字节流，可以承载多个消息。帧通过自己的**流 ID**，确定自己属于哪个报文，就可以不按顺序进行请求响应了。

   - HTTP/2 会将所有 HTTP 请求打散成帧，在一个 TCP 连接上做**并发请求**，充分利用 TCP 带宽。现在浏览器对于 HTTP2，只会建立一个 TCP 连接，减轻了服务端不小压力。
2. **首部压缩**，HTTP/2 针对头部字段，也采用了对应的**压缩算法**——`HPACK`，对请求头进行压缩。HPACK使用了`静态字典`和`动态字典`来压缩和解压缩HTTP头部信息。会在客户端和服务器端共同维护这两张表
   * **静态字典**：其中包含了一些**常见**的HTTP头部字段和值的编码。这些编码在编译HTTP/2实现时就已经确定了，并预先存储在客户端和服务器端。这样，当需要发送这些头部字段时，只需要发送对应的**编码值**即可，而不需要发送原始的头部字段和值。
   * **动态字典**：用于存储当前会话中使用到的自定义头部字段和值的编码。当需要发送自定义头部字段时，会将其添加到动态字典中，并发送对应的**编码值**。这样可以避免重复发送相同的头部字段和值。
   * 发送和接受数据时，会拿**编码值**与字典表进行对比，然后把真实值取出来即可。
3. **服务器推送**，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。

### 减少HTTP请求数量，减少http请求大小
#### 利用webpack压缩文件，文件合并，实现减少HTTP请求数量，减少http请求大小
压缩文件 -> 减少HTTP请求大小,可以减少请求时间
文件合并 -> 减少HTTP请求数量。

现在可以很方便的用webpack实现文件的压缩

- 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
- 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 base64 的方式写入文件中
- 按照路由拆分代码，实现**按需加载**
- 给打包出来的文件名添加哈希，实现浏览器缓存文件
- Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存

#### 避免重复请求
1. 给触发请求的动作设置**防抖，节流**，或者设置disable
节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时
2. **axios拦截器**：
    我们创建了一个axios实例，并定义了一个`pendingRequests`对象来存储正在进行的请求。在请求拦截器中，我们根据请求的url和请求方法生成一个唯一标识符，并检查是否已经存在相同的请求。如果存在相同的请求，我们使用`cancelToken`取消当前请求。否则，将新的请求添加到`pendingRequests`对象中。在响应拦截器中，无论请求成功或失败，我们都将该请求从`pendingRequests`对象中移除。
    ```javascript
    import axios from 'axios';

    // 创建一个axios实例
    const instance = axios.create();

    // 定义一个对象来存储正在进行的请求
    const pendingRequests = {};

    // 请求拦截器
    instance.interceptors.request.use((config) => {
      // 根据请求的url和请求方法生成一个唯一标识符
      const requestKey = `${config.url}_${config.method}`;

      // 检查是否已经存在相同的请求
      if (pendingRequests[requestKey]) {
        // 如果存在相同的请求，取消当前请求
        config.cancelToken = new axios.CancelToken((cancel) => {
          cancel('Duplicate request detected.');
        });
      } else {
        // 如果是新的请求，将其添加到pendingRequests对象中
        pendingRequests[requestKey] = true;
      }

      return config;
    }, (error) => {
      return Promise.reject(error);
    });

    // 相应拦截器
    instance.interceptors.response.use((response) => {
      // 根据请求的url和请求方法生成一个唯一标识符
      const requestKey = `${response.config.url}_${response.config. method}`;

      // 请求完成后，将其从pendingRequests对象中移除
      delete pendingRequests[requestKey];

      return response;
    }, (error) => {
      // 请求失败后，将其从pendingRequests对象中移除
      const requestKey = `${error.config.url}_${error.config.method}    `;
      delete pendingRequests[requestKey];

      return Promise.reject(error);
    });
### 懒加载

懒加载也叫做**延迟加载、按需加载**

优点：
- 减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。
- 提升用户体验: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。
- 防止加载过多图片而影响其他资源文件的加载 ：会影响网站应用的正常使用。

#### 实现
- `React.lazy` + `import()` + `Suspense`:React利用 React.lazy与import()实现了渲染时的动态加载 ，并利用Suspense来处理异步加载资源时页面应该如何显示的问题。
  ```js
  import React, { Suspense } from 'react';

  const OtherComponent = React.lazy(() => import('./  OtherComponent'));

  function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <OtherComponent />
        </Suspense>
      </div>
    );
  }
  ```

#### 懒加载与预加载的区别

两者主要区别是一个是提前加载，一个是迟缓甚至不加载。
- 懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载
- 预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。

### 服务器端渲染
客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。

服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

优点：首屏渲染快，SEO 好。
缺点：配置麻烦，增加了服务器的计算压力。

### 文件优化

- `图片加载优化`
  - 减少图片使用，用css替代
  - 小图使用base64格式，或SVG
  - 雪碧图
  - 使用`WebP`格式图片，它提供了有损压缩与无损压缩（可逆压缩）的图片文件格式
- `其他文件优化`
  - CSS 文件放在 head 中
  - 服务端开启文件压缩功能
  - 将 script 标签放在 **body 底部**，因为 JS 文件执行会阻塞渲染。或者把 script 标签放在任意位置然后加上 `defer` ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 `async` ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。
  - `webworker`：执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 Webworker。`Webworker` 可以让我们另开一个线程执行脚本而不影响渲染。
  
### 静态资源使用CDN
`CDN`是指一种通过互联网互相连接的电脑网络系统，利用**最靠近**每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。

典型的CDN系统由下面三个部分组成：
- **分发服务系统**： 最基本的工作单元就是`Cache`设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容**同步**，把更新的内容以及本地没有的内容从源站点获取并保存在本地。
- **负载均衡系统**：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。
- **运营管理系统**：负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。

**CDN的作用**：
- 性能方面：
  - 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快
  - 部分资源请求分配给了CDN，减少了服务器的负载
- 安全方面：CDN有助于防御DDoS、MITM等网络攻击

### 资源缓存
- 本地web存储
- http缓存强缓存、协商缓存。详见[《缓存 - 浏览器(http)缓存》](../浏览器/缓存-浏览器(http)缓存(强缓存，协商缓存))章节。
  - 选择合适的缓存策略：
    - 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
    - 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
    - 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然 后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

## 运行时性能优化


### 避免回流与重绘
**回流**：当渲染树中部分或者全部元素的**尺寸、结构或者属性**发生变化时会触发浏览器回流。

**重绘**：更新元素的绘制属性（元素的颜色、背景色、边框等），会触发重绘制。

>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。

**如何避免回流和重绘**
- 使用 class 操作样式，而不是频繁操作 style
- 避免使用 table 布局
- 避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- Debounce window resize 事件
- 对 dom 属性的读写要分离
- will-change: transform 做优化，等

### 节流和防抖，滚动事件性能优化

- **防抖**是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。
  - 适用于**按钮提交场景**：防⽌多次提交按钮，只执⾏最后提交的⼀次
- **节流**是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。
  - 适用于**拖拽场景，缩放场景，动画场景**

手写防抖：
```js
function debounce(fn, wait) {
  var timer = null;

  return function() {
    let args = [...arguments];

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(this, args); // 将我们执行回调方法时的上下文绑定在回调函数上
    }, wait);
  };
}

debounceElement.onclick = debounce(handleClick, 300);
```

手写节流
```js
// 时间戳版
function throttle(fn, delay) {
  let preTime = Date.now();

  return function() {
    let args = [...arguments],
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(this, args);
    }
  };
}
debounceElement.onclick = throttle(handleClick, 300);
```

### 使用 Web Workers
Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。

Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。

不过在 worker 内，不能直接操作 DOM 节点，也不能使用 window 对象的默认方法和属性。然而你可以使用大量window 对象之下的东西，包括 WebSockets，IndexedDB 以及 FireFox OS 专用的 Data Store API 等数据存储机制。

### 写代码时的优化点
- 优先使用switch语句，当判定条件越来越多时， 越倾向于使用switch,而不是if-else
- 布局上使用flexbox
- 使用位操作
- 降低 CSS 选择器的复杂性

# Webpack
- 对于 Webpack4，打包项目使用 `production` 模式，这样会自动开启**代码压缩**
- 使用 ES6 模块来开启 `tree shaking`，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 `base64` 的方式写入文件中
- 按照路由拆分代码，实现**按需加载**
- 给打包出来的文件名添加哈希，实现浏览器**缓存**文件
- `Code Splitting`: 将代码按路由维度或者组件**分块**(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存
