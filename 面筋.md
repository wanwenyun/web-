### 滴滴 - 一面
#### 项目有什么难点？
一定要总结一下～～
权限控制？

#### 为什么用nest？在使用过程中遇到什么问题吗？
流式编码？ -- 不说，因为说不清楚
依赖注入，详见[《项目梳理》](./%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D.md)

#### 项目有什么运维手段？

#### 机器部署？容器部署？

**静态网站**是指所有的网页都由静态内容构成，包括客户端执行的脚本（例如JavaScript）。您可以通过静态网站托管功能将您的静态网站托管到OSS的存储空间（Bucket），并使用Bucket的访问域名访问这个网站。

#### 有自定义过什么hook吗？


#### 如何实现一个监听window.resize事件的hook?
```js
import React, { useState, useEffect } from "react";
const getWindowSize = () => ({
  innerHeight: window.innerHeight,
  innerWidth: window.innerWidth,
});
const [windowSize, setWindowSize] = useStat(getWindowSize());
const handleResize = () => {
  setWindowSize(getWindowSize());
};
useEffect(() => {
  // 监听
  window.addEventListener("resize",handleResize);
  // 销毁
  return () => window.removeEventListene("resize", handleResize);
});
```
#### 算法：找到页面上离指定的A，B两个节点最近的父节点
考察点：`contains`方法
```js
function commonParentNode(oNode1, oNode2) {
    if(oNode1.contains(oNode2)) return oNode1;
    if(oNode2.contains(oNode1)) return oNode2;
    let oNode1s=oNode1.parentNode;
    while(true){
        if(oNode1s.contains(oNode2)){
        return oNode1s; 
        }
        oNode1s=oNode1s.parentNode;
    }
}
```

### 快手 一面
题目：
           A

      B         C

E  F  G       H   I

子节点数不确定

树层级不确定

自行定义一个树结构

实现遍历方法，要求：

对树进行宽度遍历

```js
function treeNode(val, child) {
  this.val = val ? val : null;
  this.child = child ? child : null;
}

// 深度优先遍历
const DFS = (root) => {
  let res = [];
  function tmp(root){
    if(root) {
      res.push(root.val);
      if(root.child) {
        root.child.map(item => tmp(item))
      }
    }
  }
  tmp(root);
  return res;
}

// 宽度优先遍历
const BFS = (root) => {
  let res = [];
  let stack = [root];
  while(stack.length > 0) {
    let current = stack.shift();

    res.push(current.val);

    if(current.child) {
      stack.push(...current.child);
    }
  }
  return res;
}

console.log(BFS(new treeNode('a', [new treeNode('b', [new treeNode('c')]), new treeNode('d')])))
```