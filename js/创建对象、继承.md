- [创建对象](#创建对象)
  - [工厂模式](#工厂模式)
  - [构造函数模式](#构造函数模式)
  - [原型模式](#原型模式)
  - [组合模式:`构造函数模式`与`原型模式`双剑合璧](#组合模式构造函数模式与原型模式双剑合璧)
  - [动态原型模式](#动态原型模式)
  - [寄生构造函数模式](#寄生构造函数模式)
  - [稳妥构造函数模式](#稳妥构造函数模式)
- [继承](#继承)
  - [原型链继承](#原型链继承)
  - [借用构造函数(经典继承)](#借用构造函数经典继承)
  - [组合继承 = 原型链继承+经典继承 (JavaScript 中最常用的继承模式。)](#组合继承--原型链继承经典继承-javascript-中最常用的继承模式)
  - [寄生组合式继承](#寄生组合式继承)

# 创建对象
[JavaScript深入之创建对象的多种方式以及优缺点](https://github.com/mqyqingfeng/Blog/issues/15)

## 工厂模式

```js
function createPerson(name) {
    var o = new Object();
    o.name = name;
    o.getName = function () {
        console.log(this.name);
    };

    return o;
}

var person1 = createPerson('kevin');
```

缺点：

1. 对象无法识别，因为所有的实例都指向一个原型
2. 每次通过Person创建对象的时候，所有的getName方法都是一样的，但是却存储了多次，浪费资源。

## 构造函数模式

```js
function Person(name) {
    this.name = name;
    this.getName = function () {
        console.log(this.name);
    };
}

var person1 = new Person('kevin');
console.log(person1 instanceof Person); // true
```

优点：实例可以识别为一个特定的类型

缺点：每次创建实例时，每个方法都要被创建一次

## 原型模式

```js
function Person(name) {}

Person.prototype = {
    constructor: Person,
    name: 'kevin',
    friends: ['hah','enen'],
    getName: function () {
        console.log(this.name);
    }
};

Person.prototype.showFriends = function() {
    console.log(this.friends)
  }

var person1 = new Person();
var person2 = new Person();
person1.friends.push('test');
person1.showFriends(); // [ 'hah', 'enen', 'test' ]
person2.showFriends(); // [ 'hah', 'enen', 'test' ]
```

优点：

1. 原型上的方法（比如：getName（））可以被共享，所有的实例的getName（）方法指向同一个
2. 可以动态的添加原型对象的方法和属性，并直接反映在对象实例上。

缺点：

1. `引用类型`属性会被`实例`共享
2. 所有的`方法`都是`共享`的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样`传递参数`

## 组合模式:`构造函数模式`与`原型模式`双剑合璧

```js
function Person(name) {
    this.name = name;
    this.friends = ['lilei'];
}

Person.prototype = {
    constructor: Person,
    getName: function () {
        console.log(this.name);
    }
};

var person1 = new Person('test');
var person2 = new Person('test2')
person2.friends.push('hahah');
person1.getName(); // test
console.log(person1); // Person { name: 'test', friends: [ 'lilei' ] }
console.log(person2); // Person { name: 'test2', friends: [ 'lilei', 'hahah' ] }
```

优点：

1. 解决了原型模式对于引用对象的缺点
2. 解决了原型模式没有办法传递参数的缺点
3. 解决了构造函数模式不能共享方法的缺点

## 动态原型模式

## 寄生构造函数模式

```js
function Person(name) {
    var o = new Object()
    o.name = name
    o.getName = function() {
      console.log(this.name)
    }
    return o
  }
  var peron1 = new Person('hanmeimei');
  peron1.getName(); // hanmeimei
```

## 稳妥构造函数模式

```js
function Person(name) {
    var o = new Object()
    o.getName = function() {
      console.log(name)
    }
    return o;
  }
  var person1 = new Person('hanmeimei');
  console.log(person1.name);  // undefined
  person1.getName(); //hanmeimei
```

# 继承

[JavaScript深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16)

## 原型链继承

```js
function Parent () {
    this.name = ['kevin', 'daisy'];
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child () {}

Child.prototype = new Parent();


// 测试
var child1 = new Child();
child1.names.push('yayu');
console.log(child1.getName()) // ["kevin", "daisy", "yayu"]
var child2 = new Child();
console.log(child2.names); // ["kevin", "daisy", "yayu"]
```

缺点：

1. 子类实例会`共享`父类`引用对象`，这样如果不小心修改了原型对象中的`引用类型`属性，那么所有子类创建的实例对象都会`受到影响`(这点从修改child1.arr可以看出来)
2. 子类无法向父类传参。

## 借用构造函数(经典继承)

```js
function Parent (name) {
    this.name = name;
    this.friends = ['kevin', 'daisy'];
}

function Child (name) {
    Parent.call(this, name);
}

// 测试
var child1 = new Child('wanwan');
child1.friends.push('yayu');
console.log(child1.friends, child1.name); // ["kevin", "daisy", "yayu"] "wanwan"
var child2 = new Child('yunyun');
console.log(child2.friends, child1.name); // ["kevin", "daisy"] "yunyun"
```

优点：

1.避免了引用类型的属性被所有实例共享
2.可以在 Child 中向 Parent 传参

缺点：
方法都在构造函数中定义，每次创建实例都会创建一遍方法。

## 组合继承 = 原型链继承+经典继承 (JavaScript 中最常用的继承模式。)

```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {

    Parent.call(this, name);
    
    this.age = age;

}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

## 寄生组合式继承

