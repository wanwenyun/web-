import{_ as s,o as a,c as l,V as n}from"./chunks/framework.75331a37.js";const o="/assets/pic1.16e10aea.png",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端框架/前端框架原理.md","filePath":"前端框架/前端框架原理.md"}'),p={name:"前端框架/前端框架原理.md"},t=n(`<blockquote><p>参考文章：<a href="https://juejin.cn/post/7194473892268736549" target="_blank" rel="noreferrer">浅谈前端框架原理</a></p></blockquote><h2 id="前端框架" tabindex="-1">前端框架 <a class="header-anchor" href="#前端框架" aria-label="Permalink to &quot;前端框架&quot;">​</a></h2><p><strong>UI = f(state)</strong></p><p>其中：</p><ul><li>state —— 当前的视图的状态</li><li>f —— 框架内部的运行机制</li><li>UI —— 宿主环境的视图</li></ul><p>这个公式说明，<strong>框架内部运行机制根据当前状态渲染视图</strong>，这也能看出现代框架的一个重要特性：<strong>数据驱动</strong>。</p><h2 id="如何描述ui" tabindex="-1">如何描述UI <a class="header-anchor" href="#如何描述ui" aria-label="Permalink to &quot;如何描述UI&quot;">​</a></h2><ul><li><p><code>JSX</code>：Facebook提出的一种 ECMAScript 的语法糖。JSX在运行时会被转换成浏览器能够识别的标准ES语法。例如React用的便是JSX。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> element </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> (</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Hello!</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h2</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Good to see you here.</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h2</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  )</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>JSX在编译时会被Babel编译为<code>React.createElement</code>方法。</p></li><li><p>template 模板：它扩充的是 HTML 语法，例如VUE中的模版</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> msg </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello World!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">{{ msg }}</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-model</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">msg</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></li></ul><h2 id="数据驱动" tabindex="-1">数据驱动 <a class="header-anchor" href="#数据驱动" aria-label="Permalink to &quot;数据驱动&quot;">​</a></h2><p>说的是，在数据驱动框架中，状态变化，会引起UI的变化。</p><p>框架内部运行机制的实现，可以概括为以下两个步骤：</p><ol><li>根据 state 计算出 UI 变化，如， Vue 和 React 通过对比变化前后的 VNode，知道需要更新哪些元素</li><li>根据 UI 变化，执行具体宿主（如浏览器）的 API。</li></ol><p>拆分成两个步骤是为了做到与<strong>平台无关</strong>。前端框架通常会抽离出一套抽象的元素操作的 API，例如：新增/删除/移动元素、修改元素属性等原子操作。不会直接操作浏览器 DOM。</p><p>例如：React、Vue 可以开发浏览器、Canvas、安卓、IOS 的系统/应用，因为其本身不与任何平台耦合，只需要提供相应的宿主 API，就能做到跨平台使用框架。</p><p>不同框架，主要的差异其实是在步骤一，如何根据 state 找到 UI 变化的部分: <img src="`+o+'"></p><ul><li>React 属于应用级框架</li><li>Vue 属于组件级框架</li><li>Svelte 属于元素级框架</li></ul><h2 id="前端用到的技术" tabindex="-1">前端用到的技术 <a class="header-anchor" href="#前端用到的技术" aria-label="Permalink to &quot;前端用到的技术&quot;">​</a></h2><h3 id="响应式" tabindex="-1">响应式 <a class="header-anchor" href="#响应式" aria-label="Permalink to &quot;响应式&quot;">​</a></h3><p>//TODO: 待补充</p><ul><li>Vue响应式</li></ul><p>实现了细粒度的更新，是组件级应用的一种实现</p><h3 id="victual-dom" tabindex="-1">Victual DOM <a class="header-anchor" href="#victual-dom" aria-label="Permalink to &quot;Victual DOM&quot;">​</a></h3><p>Vdom的作用：</p><ul><li>描述 UI</li><li>通过对比 VDOM 前后的变化，计算出 UI 中变化的部分。即 Diff。</li></ul><p>Vdom优点：</p><ul><li>相对于 DOM 有体积优势</li><li>多平台渲染能力</li></ul><blockquote><p>VDOM 可以多平台渲染能力，但反过来，多平台渲染能力，不一定需要 VDOM VDOM 的最终目的，其实是用于 <strong>Diff</strong>，计算出 UI 中变化的部分。但刚好又可以用于多平台渲染。</p></blockquote><p><strong>应用级框架和组件级框架</strong>，需要使用 <strong>VDOM 配合 Diff</strong> 算法，计算出 UI 中变化的元素。</p><p>元素级框架，如 Svelte，由于可以直接精准的找到 UI 变化的部分，不需要 Diff，则可以直接不使用 VDOM 技术。</p><p>总结：最终目的是快速找出一组 UI 元素中变化的部分，<strong>应用级和组件级</strong>框架需要使用。元素级框架由于直接指导变化的元素，因此不需要。</p><h3 id="aot预编译技术" tabindex="-1">AOT预编译技术 <a class="header-anchor" href="#aot预编译技术" aria-label="Permalink to &quot;AOT预编译技术&quot;">​</a></h3><p>在前端框架一般都有编译这一步骤，用于：</p><ol><li>代码转换，如：ts 编译为 js，Vue 将 vue 文件转换成 js</li><li>编译优化</li><li>代码压缩、打包</li></ol><p>编译有两个执行时机：</p><ul><li>构建时编译（AOT，预编译）：可以提前进行编译，用户直接运行编译后的代码，可以减少首屏时间。</li><li>运行时编译（JIT，即时编译）：会消耗更多时间用于编译，且应用代码体积会更大，因为需要包含编译的相关逻辑。</li></ul><p>使用模板的框架，能从 AOT 预编译优化中受益，因为模板的结构固定，容易分析。JSX 则难以优化，除非约束 JSX 的灵活性</p>',36),e=[t];function r(c,i,D,F,y,A){return a(),l("div",null,e)}const d=s(p,[["render",r]]);export{u as __pageData,d as default};
