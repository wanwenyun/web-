import{_ as s,o as a,c as n,V as l}from"./chunks/framework.75331a37.js";const o="/assets/pic1.10518efc.png",p="/assets/pic2.0d112b52.png",e="/assets/pic3.7f199292.png",t="/assets/pic4.b3a02497.png",r="/assets/pic5.0a857fb2.png",c="/assets/pic6.a571ccec.png",i="/assets/pic7.7717576c.png",y="/assets/pic8.7b37805f.png",F="/assets/pic9.f248c18c.png",D="/assets/pic10.7c4fcc85.png",A="/assets/pic11.77e00f6a.png",C="/assets/pic12.d51fcf38.png",g="/assets/task-manager.7229281a.png",d="/assets/performance.ce5b5d78.png",q=JSON.parse('{"title":"前言","description":"","frontmatter":{},"headers":[],"relativePath":"Google V8/V8(3) - 垃圾回收机制，内存泄露.md","filePath":"Google V8/V8(3) - 垃圾回收机制，内存泄露.md"}'),u={name:"Google V8/V8(3) - 垃圾回收机制，内存泄露.md"},h=l(`<ul><li><a href="#前言">前言</a><ul><li><a href="#垃圾数据如何产生">垃圾数据如何产生？</a></li></ul></li><li><a href="#垃圾回收garbage-collection算法">垃圾回收(Garbage Collection)算法</a><ul><li><a href="#副垃圾回收器---新生代垃圾回收---scavenge算法">副垃圾回收器 - 新生代垃圾回收 - Scavenge算法</a></li><li><a href="#主垃圾回收器---老生代垃圾回收---标记清除mark-sweep算法-标记整理mark-compact算法">主垃圾回收器 - 老生代垃圾回收 - 标记/清除(Mark-Sweep)算法， 标记/整理(Mark-Compact)算法</a></li></ul></li><li><a href="#垃圾回收算法的优化">垃圾回收算法的优化</a><ul><li><a href="#并行回收---副垃圾回收器">并行回收 - 副垃圾回收器</a></li><li><a href="#增量回收">增量回收</a></li><li><a href="#并发-concurrent-回收">并发 (concurrent) 回收</a></li><li><a href="#主垃圾回收器--并行--增量--并发">主垃圾回收器 = 并行 + 增量 + 并发</a></li></ul></li><li><a href="#内存泄露">内存泄露</a><ul><li><a href="#常见的几种内存泄露情况">常见的几种内存泄露情况</a></li><li><a href="#如何发现内存泄露">如何发现内存泄露</a></li></ul></li></ul><blockquote><p>参考链接：<a href="https://time.geekbang.org/column/article/230845" target="_blank" rel="noreferrer">https://time.geekbang.org/column/article/230845</a></p></blockquote><h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h1><p>JavaScript 是一门自动垃圾回收的语言，也就是说，我们不需要去手动回收垃圾数据，这一切都交给 V8 的垃圾回收器来完成。V8 为了更高效地回收垃圾，引入了两个垃圾回收器，它们分别针对着不同的场景。</p><h2 id="垃圾数据如何产生" tabindex="-1">垃圾数据如何产生？ <a class="header-anchor" href="#垃圾数据如何产生" aria-label="Permalink to &quot;垃圾数据如何产生？&quot;">​</a></h2><p>无论是使用什么语言，我们都会频繁地使用数据，这些数据会被存放到栈和堆中，通常的方式是在内存中创建一块空间，使用这块空间，在不需要的时候回收这块空间。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">test </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">test</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Uint16Array</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">100</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>当 JavaScript 执行这段代码的时候，会先为 window 对象添加一个 test 属性，并在堆中创建了一个空对象，并将该对象的<strong>地址</strong>指向了 window.test 属性。随后又创建一个大小为 100 的数组，并将属性地址指向了 test.a 的属性值。此时的内存布局图如下所示：</p><img src="`+o+'" width="80%/"><p>如果此时，我将另外一个对象赋给了 a 属性，代码如下所示：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">test</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Object</span><span style="color:#A6ACCD;">()</span></span></code></pre></div><p>此时内存布局如下：</p><img src="'+p+'" width="80%/"><p>此时Array对象变成了垃圾数据，因为我们无法访问到此对象</p><p>但这个数组对象不会一直占用内存空间，因为 V8 虚拟机中的<strong>垃圾回收器</strong>会帮你自动清理。</p><h1 id="垃圾回收-garbage-collection-算法" tabindex="-1">垃圾回收(Garbage Collection)算法 <a class="header-anchor" href="#垃圾回收-garbage-collection-算法" aria-label="Permalink to &quot;垃圾回收(Garbage Collection)算法&quot;">​</a></h1><p><strong>大体步骤：</strong></p><ul><li>第一步：通过 GC Root 标记空间中<strong>活动对象</strong>和<strong>非活动对象</strong>。 <ul><li>目前 V8 采用的可访问性（reachability）算法来判断堆中的对象是否是活动对象。可通过CG root访问到的是<strong>活动对象</strong>，需在内存中保留。否则，是非活动对象，不需要保留。</li><li>常见的GC root有： <ol><li>全局的 window 对象（位于每个 iframe 中）</li><li>文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；</li><li>存放栈上变量。</li></ol></li></ul></li><li>第二步：<strong>回收非活动对象</strong>所占据的内存：在标记完成后，统一清理内存中所有被标记为非活动对象。</li><li>第三步：做内存整理。</li></ul><p>由于受<em>代际假说</em>的影响，目前 V8 采用了以下两个垃圾回收器：</p><ul><li><strong>副垃圾回收器 -Minor GC (Scavenger)</strong>，主要负责新生代的垃圾回收。</li><li><strong>主垃圾回收器 -Major GC</strong>，主要负责老生代的垃圾回收。</li></ul><blockquote><p>在 V8 中，会把堆分为新生代和老生代两个区域，<strong>新生代</strong>中存放的是生存时间<strong>短</strong>的对象，<strong>老生代</strong>中存放生存时间<strong>久</strong>的对象。 V8 的堆内存，是新生代内存和老生代内存之和。</p><p>新生代通常只支持 1～8M 的容量，而老生代支持的容量就大很多了。所以V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p></blockquote><h2 id="副垃圾回收器-新生代垃圾回收-scavenge算法" tabindex="-1">副垃圾回收器 - 新生代垃圾回收 - Scavenge算法 <a class="header-anchor" href="#副垃圾回收器-新生代垃圾回收-scavenge算法" aria-label="Permalink to &quot;副垃圾回收器 - 新生代垃圾回收 - Scavenge算法&quot;">​</a></h2><p>副垃圾回收器主要负责新生代的垃圾回收。</p><p>新生代区域中对象的特点：对象占用空间小，存活时间短，触发回收操作频繁。</p><p><strong>Scavenge算法</strong> Scavenge 算法把新生代空间对半划分为两个区域，一半是<strong>对象区域 (from-space)，一半是空闲区域 (to-space)</strong>。</p><img src="'+e+'" width="80%/"><p>新加入的对象都会存放到<strong>对象</strong>区域，当<strong>对象区域</strong>快被写满时，就需要执行一次垃圾清理操作。</p><p><strong>Scavenge算法具体步骤如下：</strong></p><ol><li><p>V8会把<strong>对象区</strong>中的对象做一遍检查，将数据分为活动数据和垃圾数据。然后把<strong>活动数据</strong>对象复制到<strong>空闲区</strong>，同时它还会把这些对象有序地排列起来，相当于完成了内存整理操作。垃圾数据直接回收即可。</p><img src="'+t+'" width="80%/"></li><li><p>对象区与空闲区进行<strong>角色翻转</strong>，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了一次垃圾回收。如此循环。 <img src="'+r+'" width="80%/"></p></li></ol><p>优点：</p><ol><li>有效解决了内存碎片的问题。</li><li>时间性能非优秀：因为每次执行回收时都有从对象区<strong>复制</strong>到空闲区的操作，需要时间成本，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域，便很快执行下一次垃圾回收。</li></ol><p>缺点：Scavenge 算法内存只能使用新生代内存的一半</p><h2 id="主垃圾回收器-老生代垃圾回收-标记-清除-mark-sweep-算法-标记-整理-mark-compact-算法" tabindex="-1">主垃圾回收器 - 老生代垃圾回收 - 标记/清除(Mark-Sweep)算法， 标记/整理(Mark-Compact)算法 <a class="header-anchor" href="#主垃圾回收器-老生代垃圾回收-标记-清除-mark-sweep-算法-标记-整理-mark-compact-算法" aria-label="Permalink to &quot;主垃圾回收器 - 老生代垃圾回收 - 标记/清除(Mark-Sweep)算法， 标记/整理(Mark-Compact)算法&quot;">​</a></h2><p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过<strong>多次回收</strong>后依然存在，那么就会被放入到<strong>老生代内存</strong>中，这就是<code>对象晋升策略</code>。</p><p>老生代中的对象的特点：对象占用空间大，存活时间长，触发回收操作不频繁。</p><p>若要在老生代中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。所以，主垃圾回收器是采用<strong>标记/清除（Mark-Sweep）算法</strong>进行垃圾回收的。</p><p><strong>标记/清除（Mark-Sweep）算法具体步骤如下：</strong></p><ol><li><strong>标记阶段：</strong> 从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</li><li><strong>垃圾清除阶段：</strong> 它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会<strong>直接</strong>将标记为垃圾的数据清理掉。</li></ol><p>你可以理解这个过程是清除掉下图中红色标记数据的过程，你可参考下图大致理解下其清除过程：</p><img src="'+c+'" width="80%/"><p>对垃圾数据进行标记，然后清除，这就是<strong>标记/清除算法</strong>，该算法的缺点很明显，会产生大量<strong>不连续</strong>的内存碎片。</p><p>为了解决碎片过多会导致大对象无法分配到足够的连续内存的问题，引入了另外一种算法，<strong>标记/整理（Mark-Compact）</strong>。</p><p>这个算法的标记过程仍然与标记/清除算法里的是一样的，先标记可回收对象，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉这一端之外的内存。你可以参考下图：</p><img src="'+i+'" width="80%/"><h1 id="垃圾回收算法的优化" tabindex="-1">垃圾回收算法的优化 <a class="header-anchor" href="#垃圾回收算法的优化" aria-label="Permalink to &quot;垃圾回收算法的优化&quot;">​</a></h1><p>由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本<strong>暂停</strong>下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿</strong>。全停顿的执行效果如下图所示： <img src="'+y+'" width="80%/"></p><p>为了解决全停顿而造成的用户体验的问题，V8 团队经过了很多年的努力，向现有的垃圾回收器添加<strong>并行、并发和增量</strong>等垃圾回收技术。这些技术主要是从两方面来解决垃圾回收效率问题的：</p><ul><li>第一，<strong>将一个完整的垃圾回收的任务拆分成多个小的任务</strong>，这样就消灭了单个长的垃圾回收任务；</li><li>第二，<strong>将标记对象、移动对象等任务转移到后台线程进行</strong>，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅。</li></ul><h2 id="并行回收-副垃圾回收器" tabindex="-1">并行回收 - 副垃圾回收器 <a class="header-anchor" href="#并行回收-副垃圾回收器" aria-label="Permalink to &quot;并行回收 - 副垃圾回收器&quot;">​</a></h2><p>并行回收，是指垃圾回收器在主线程上执行的过程中，还会开启多个协助线程，同时执行同样的回收工作，其工作模式如下图所示：</p><img src="'+F+'" width="80%/"><p>执行垃圾标记的过程中，主线程并不会同时执行 JavaScript 代码。</p><p>采用并行回收时，垃圾回收所消耗的时间，等于总体辅助线程所消耗的时间（辅助线程数量乘以单个线程所消耗的时间），再加上一些同步开销的时间。</p><p>V8 的<strong>副垃圾回收器</strong>所采用的就是并行策略。它在执行垃圾回收的过程中，启动了多个线程来负责<strong>新生代</strong>中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域。由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针。</p><p>虽然提升了效率，但这还是<strong>全停顿</strong>的垃圾回收方式。</p><h2 id="增量回收" tabindex="-1">增量回收 <a class="header-anchor" href="#增量回收" aria-label="Permalink to &quot;增量回收&quot;">​</a></h2><p>增量式垃圾回收，是指垃圾收集器将标记工作分解为<strong>更小</strong>的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作，具体流程你可以参看下图： <img src="'+D+'" width="80%/"></p><p>增量回收是并发的（concurrent），要实现增量执行，需要满足两点要求：</p><ol><li>垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后，才能继续启动。</li><li>在暂停期间，被标记好的垃圾数据如果被 JavaScript 代码修改了，那么垃圾回收器需要能够正确地处理。</li></ol><p>在没有采用增量算法之前，V8 使用<strong>黑色和白色</strong>来标记数据。</p><p>如果内存中的数据只有两种状态，非黑即白，那么当你暂停了当前的垃圾回收器之后，再次恢复垃圾回收器，那么垃圾回收器就不知道从哪个位置继续开始执行了。</p><p>为了解决这个问题，V8 采用了三色标记法，除了黑色和白色，还额外引入了灰色：</p><ul><li>黑色表示这个节点被 GC Root 引用到了，而且该节点的子节点都已经标记完成了 ;</li><li>灰色表示这个节点被 GC Root 引用到，但子节点还没被垃圾回收器标记处理，也表明<strong>目前正在处理这个节点</strong>；</li><li>白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回。</li></ul><p>引入灰色标记之后，垃圾回收器就可以依据当前内存中<strong>有没有灰色节点</strong>，来判断整个标记<strong>是否完成</strong>，如果没有灰色节点了，就可以进行清理工作了。如果还有灰色标记，当下次恢复垃圾回收器时，便从灰色的节点开始继续执行。</p><h2 id="并发-concurrent-回收" tabindex="-1">并发 (concurrent) 回收 <a class="header-anchor" href="#并发-concurrent-回收" aria-label="Permalink to &quot;并发 (concurrent) 回收&quot;">​</a></h2><p>增量回收是在主线程上执行的，如果主线程繁忙的时候，增量垃圾回收操作依然会增加主线程处理任务的吞吐量。</p><p>为了在不阻塞主线程的情况下，执行垃圾回收操作，引入了<strong>并发回收机制</strong>。</p><p>所谓并发回收，是指主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作。并发标记的流程大致如下图所示： <img src="'+A+'" width="80%/"></p><p>并发回收的优势非常明显，主线程<strong>不会被挂起</strong>，JavaScript 可以自由地执行 ，在执行的同时，辅助线程可以执行垃圾回收操作。</p><p>但是并发回收却是这三种技术中最难的一种，这主要由以下两个原因导致的：</p><ul><li>第一，当主线程执行 JavaScript 时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全无效；</li><li>第二，主线程和辅助线程极有可能在同一时间去更改同一个对象，这就需要额外实现读写锁的一些功能了。</li></ul><h2 id="主垃圾回收器-并行-增量-并发" tabindex="-1">主垃圾回收器 = 并行 + 增量 + 并发 <a class="header-anchor" href="#主垃圾回收器-并行-增量-并发" aria-label="Permalink to &quot;主垃圾回收器 = 并行 + 增量 + 并发&quot;">​</a></h2><p>V8 的主垃圾回收器就融合了上面介绍的三种机制，来实现垃圾回收. <img src="'+C+`" width="80%/"></p><p><strong>主垃圾回收器</strong>同时采用了这三种策略：</p><ul><li>首先主垃圾回收器主要使用<strong>并发标记</strong>，我们可以看到，在主线程执行 JavaScript，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的。</li><li>标记完成之后，再执行<strong>并行</strong>清理操作。主线程在执行清理操作时，多个辅助线程也在执行清理操作。</li><li>另外，主垃圾回收器还采用了<strong>增量标记</strong>的方式，清理的任务会穿插在各种 JavaScript 任务之间执行。</li></ul><h1 id="内存泄露" tabindex="-1">内存泄露 <a class="header-anchor" href="#内存泄露" aria-label="Permalink to &quot;内存泄露&quot;">​</a></h1><p>不再用到的内存，没有及时释放，就叫做<strong>内存泄漏</strong>。</p><p>如果应用使用的内存越来越多，就会严重影响性能，甚至导致浏览器的崩溃。</p><p>V8的<strong>垃圾回收机制</strong>虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况。</p><h2 id="常见的几种内存泄露情况" tabindex="-1">常见的几种内存泄露情况 <a class="header-anchor" href="#常见的几种内存泄露情况" aria-label="Permalink to &quot;常见的几种内存泄露情况&quot;">​</a></h2><ol><li><p><strong>全局变量</strong></p><p>在<strong>非严格模式</strong>下当引用未声明的变量时，会在<strong>全局对象</strong>中创建一个新变量。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">（</span><span style="color:#82AAFF;">arg</span><span style="color:#A6ACCD;">）</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;">“</span><span style="color:#A6ACCD;">some</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">text</span><span style="color:#F07178;">”</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// bar将泄漏到全局.</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ul><li>原因：全局变量是根据定义无法被垃圾回收机制收集。</li><li>解决办法：严格模式（use strict）+ eslint检查</li></ul></li><li><p><strong>被遗忘的定时器和回调函数</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> someResource </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getData</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setInterval</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">node</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Node</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">node</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">         </span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">someResource</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">         </span><span style="color:#676E95;font-style:italic;">// 定时器也没有清除</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">     </span><span style="color:#676E95;font-style:italic;">// node、someResource 存储了大量数据 无法回收</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><ul><li>原因：定时器会在后台持续执行，即便定时器执行完，也还是会占用内存和CPU，直到被清除或者页面被卸载，因此它的回收不是<strong>立即</strong>发生的。</li><li>解决办法：在定时器完成工作的时候，手动清除定时器<code>clearTimeout()</code>, <code>clearInterval()</code>，保证及时回收。</li></ul></li><li><p><strong>脱离 DOM 的引用</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> refA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">refA</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">removeChild</span><span style="color:#A6ACCD;">(refA)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// dom删除了</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(refA</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">refA</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 但是还存在引用，能console出整个div，没有被回收</span></span></code></pre></div><ul><li>原因：保留了DOM节点的<strong>引用</strong>，无法被GC回收</li><li>解决方法：<code>refA = null</code></li></ul></li><li><p><strong>闭包</strong></p><p><strong>注意: 闭包本身没有错,不会引起内存泄漏.而是使用错误导致.</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">closure</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xianshannan</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">split</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">reverse</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">join</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> reverseName </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">closure</span><span style="color:#A6ACCD;">()</span></span></code></pre></div><p>在当前执行环境未结束的情况下，该段代码造成了内存泄露。</p><ul><li>原因：name 变量是被 closure 返回的函数调用了，但是返回的函数没被使用，这个场景下 name 就属于垃圾内存。name 不是必须的，但是还是占用了内存，也不可被回收。</li><li>解决办法：正确使用闭包</li></ul></li><li><p>被遗忘的事件监听器</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Demo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">FC</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">resize</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#F07178;">)</span><span style="color:#676E95;font-style:italic;">// 这里做一些操作</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;&gt;&lt;/&gt;;</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span></code></pre></div><p>上面的组件销毁的时候，resize 事件还是在监听中，里面涉及到的内存都是没法回收的（浏览器会认为这是必须的内存，不是垃圾内存）</p><p>需在组件销毁前移除相关事件</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Demo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">FC</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">resize</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#F07178;">)</span><span style="color:#676E95;font-style:italic;">// 这里做一些操作</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//此处编写 组件即将被卸载前执行的代码</span></span>
<span class="line"><span style="color:#F07178;">       </span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">removeEventListener</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">resize</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;&gt;&lt;/&gt;;</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span></code></pre></div></li><li><p>被遗忘的ES6 Set引用类型成员</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Set</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">test</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">22</span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(value)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span></code></pre></div><ul><li>解决办法 <ol><li><code>map.delete(value);</code></li><li>使用 <code>WeakSet</code>，WeakSet 的成员是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li></ol></li></ul></li><li><p>被遗忘的ES6 Map引用类型键名</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1024</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1024</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span></code></pre></div><ul><li>解决办法 <ol><li><code>map.delete(key);</code></li><li>使用 <code>WeakMap</code>，WeakMap 的键名是弱引用。</li></ol></li></ul></li></ol><h2 id="如何发现内存泄露" tabindex="-1">如何发现内存泄露 <a class="header-anchor" href="#如何发现内存泄露" aria-label="Permalink to &quot;如何发现内存泄露&quot;">​</a></h2><p><a href="https://cloud.tencent.com/developer/article/1444558" target="_blank" rel="noreferrer">参考链接</a></p><ol><li><p>Task Manager：用来粗略地查看内存使用情况</p><p>入口：<code>右上角三个点 -&gt; 更多工具 -&gt; 任务管理器</code>，然后<code>右键表头 -&gt; 勾选JS使用的内存</code><img src="`+g+'" width="80%/"></p></li><li><p>Performance：用来观察内存变化趋势 <img src="'+d+'" width="80%/"></p></li><li><p>Memory：这个面板有3个工具，分别是堆快照、内存分配情况和内存分配时间轴：</p><ul><li>堆快照（Take Heap Snapshot），用来具体分析各类型对象存活情况，包括实例数量、引用路径等等</li><li>内存分配情况（Record Allocation Profile），用来查看分配给各函数的内存大小</li><li>内存分配时间轴（Record Allocation Timeline），用来查看实时的内存分配及回收情况</li></ul></li></ol>',84),m=[h];function f(_,b,v,k,E,w){return a(),n("div",null,m)}const V=s(u,[["render",f]]);export{q as __pageData,V as default};
