import{_ as e,o as a,c as s,V as o}from"./chunks/framework.75331a37.js";const _=JSON.parse('{"title":"概览","description":"","frontmatter":{},"headers":[],"relativePath":"前端框架/React/React核心原理/React核心原理5-Concurrent-Mode.md","filePath":"前端框架/React/React核心原理/React核心原理5-Concurrent-Mode.md"}'),l={name:"前端框架/React/React核心原理/React核心原理5-Concurrent-Mode.md"},r=o('<ul><li><a href="#概览">概览</a></li><li><a href="#fiber架构">Fiber架构</a></li><li><a href="#scheduler调度器的原理与实现">Scheduler调度器的原理与实现</a></li></ul><h1 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to &quot;概览&quot;">​</a></h1><p><code>Concurrent</code> 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。由于有以下三部分底层架构的支持，才使得Concurrent模式得以实现：</p><ul><li><p><strong>Fiber架构</strong>：意义在于，他将单个组件作为工作单元，使以组件为粒度的“异步可中断的更新”成为可能。</p></li><li><p><strong>Scheduler调度器</strong>：当我们配合<code>时间切片</code>，就能根据宿主环境性能，为每个工作单元分配一个可运行时间，实现<strong>异步可中断的更新</strong>。</p><p>于是，<code>scheduler</code>（调度器）产生了。</p></li><li><p><strong>lane模型</strong>：用于控制不同<code>优先级</code>之间的关系与行为。</p></li></ul><p>从源码层面讲，Concurrent Mode是一套可控的<strong>多优先级更新架构</strong>。以下是基于Concurrent Mode的新功能。</p><ul><li><p><code>batchedUpdates</code>：合并多个“更新”的优化方式，以优先级为依据对更新进行合并的</p></li><li><p><code>Suspense</code>：可以在组件请求数据时展示一个<code>pending</code>状态。请求成功后渲染数据。本质上讲Suspense内的组件子树比组件树的其他部分拥有更低的优先级。</p></li><li><p><code>useDeferredValue</code>：返回一个延迟响应的值，该值可能“延后”的最长时间为<code>timeoutMs</code>。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> deferredValue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useDeferredValue</span><span style="color:#A6ACCD;">(value</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">timeoutMs</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2000</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>在useDeferredValue内部会调用useState并触发一次更新。</p><p>这次更新的优先级很低，所以当前如果有正在进行中的更新，不会受useDeferredValue产生的更新影响。所以useDeferredValue能够返回延迟的值。</p></li></ul><h1 id="fiber架构" tabindex="-1">Fiber架构 <a class="header-anchor" href="#fiber架构" aria-label="Permalink to &quot;Fiber架构&quot;">​</a></h1><p>详见<a href="./React核心原理1-理念(React15、fiber架构).html">《React核心原理1-理念(React15、fiber架构)》</a></p><h1 id="scheduler调度器的原理与实现" tabindex="-1">Scheduler调度器的原理与实现 <a class="header-anchor" href="#scheduler调度器的原理与实现" aria-label="Permalink to &quot;Scheduler调度器的原理与实现&quot;">​</a></h1><p>Scheduler包含两个功能</p><ul><li>时间切片</li><li>优先级调度</li></ul>',11),t=[r];function n(c,p,d,i,u,h){return a(),s("div",null,t)}const D=e(l,[["render",n]]);export{_ as __pageData,D as default};
