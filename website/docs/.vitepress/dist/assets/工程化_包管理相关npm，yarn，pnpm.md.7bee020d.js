import{_ as n,o as p,c as e,V as s}from"./chunks/framework.75331a37.js";const t="/assets/pic1.ed0262af.png",o="/assets/pic2.fe0162fb.png",r="/assets/pic4.4843b5f5.png",i="/assets/pic3.b905527c.png",w=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"工程化/包管理相关npm，yarn，pnpm.md","filePath":"工程化/包管理相关npm，yarn，pnpm.md"}'),a={name:"工程化/包管理相关npm，yarn，pnpm.md"},_=s('<h2 id="pnpm、npm、yarn" tabindex="-1">pnpm、npm、yarn <a class="header-anchor" href="#pnpm、npm、yarn" aria-label="Permalink to &quot;pnpm、npm、yarn&quot;">​</a></h2><ul><li><p><strong>npm2</strong> 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。</p><img src="'+t+'" width="30%/"><p>这样会造成：</p><ol><li>占据比较大的磁盘空间</li><li>windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的</li></ol></li><li><p><strong>npm3+ 和 yarn</strong> 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，同时还实现了<code>.lock</code>来锁定依赖版本的功能。但是引入了<strong>幽灵依赖</strong>的问题，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</p><img src="'+o+'" width="30%/"></li><li><p><strong>pnpm</strong> 则是用了另一种方式，不再是复制了，而是都从<code>全局 store 硬连接</code>到 node_modules/.pnpm，然后之间通过<code>软链接</code>来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p><figure><img src="'+r+'" width="35%/"><img src="'+i+'" width="60%/"></figure><p>缺点：pnpm查看子级依赖很不方便。</p></li></ul>',2),m=[_];function c(d,l,g,f,h,u){return p(),e("div",null,m)}const T=n(a,[["render",c]]);export{w as __pageData,T as default};
