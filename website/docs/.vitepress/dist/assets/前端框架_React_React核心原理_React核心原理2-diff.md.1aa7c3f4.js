import{_ as s,o as n,c as l,V as a}from"./chunks/framework.75331a37.js";const p="/assets/singleDiff.cd47bf1a.png",d=JSON.parse('{"title":"前置知识","description":"","frontmatter":{},"headers":[],"relativePath":"前端框架/React/React核心原理/React核心原理2-diff.md","filePath":"前端框架/React/React核心原理/React核心原理2-diff.md"}'),o={name:"前端框架/React/React核心原理/React核心原理2-diff.md"},e=a(`<ul><li><a href="#前置知识">前置知识</a></li><li><a href="#diff算法">Diff算法</a><ul><li><a href="#概览">概览</a><ul><li><a href="#diff的瓶颈以及react如何应对">Diff的瓶颈以及React如何应对</a></li><li><a href="#diff是如何实现的">Diff是如何实现的</a></li></ul></li><li><a href="#单节点diff">单节点diff</a></li><li><a href="#多节点diff">多节点Diff</a><ul><li><a href="#diff思路">Diff思路</a></li><li><a href="#第一轮遍历">第一轮遍历</a></li><li><a href="#第二轮遍历">第二轮遍历</a><ul><li><a href="#分析newchildren与oldfiber都没遍历完的情况处理移动的节点">分析<code>newChildren</code>与<code>oldFiber</code>都没遍历完的情况（处理移动的节点）</a></li></ul></li></ul></li></ul></li></ul><h1 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to &quot;前置知识&quot;">​</a></h1><p><code>effectTag</code>：它表示，Render阶段结束后，通知Render（渲染器）要执行的DOM操作类型。保存在<code>fiber.effectTag</code>上。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要插入到页面中</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Placement </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*                */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b00000000000010</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要更新</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Update </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*                   */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b00000000000100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要插入到页面中并更新</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> PlacementAndUpdate </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*       */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b00000000000110</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要删除</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Deletion </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*                 */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000100</span></span></code></pre></div><h1 id="diff算法" tabindex="-1">Diff算法 <a class="header-anchor" href="#diff算法" aria-label="Permalink to &quot;Diff算法&quot;">​</a></h1><blockquote><p><a href="https://react.iamkasong.com/diff/prepare.html#diff%E7%9A%84%E7%93%B6%E9%A2%88%E4%BB%A5%E5%8F%8Areact%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9" target="_blank" rel="noreferrer">Diff算法</a></p></blockquote><h2 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to &quot;概览&quot;">​</a></h2><blockquote><p>为了防止概念混淆，这里再强调下</p><p>一个DOM节点在某一时刻最多会有4个节点和他相关。</p><ol><li><p><code>current Fiber</code>。如果该DOM节点已在页面中，current Fiber代表该DOM节点对应的&gt;Fiber节点。</p></li><li><p><code>workInProgress Fiber</code>。如果该DOM节点将在本次更新中渲染到页面中,workInProgress Fiber代表该DOM节点对应的Fiber节点。</p></li><li><p><code>DOM节点本身</code>。</p></li><li><p><code>JSX对象</code>。即ClassComponent的render方法的返回结果，或FunctionComponent的调用结果。JSX对象中包含描述DOM节点的信息。</p></li></ol><p>Diff算法的本质是对比<code>1</code>和<code>4</code>，生成<code>2</code>。</p></blockquote><h3 id="diff的瓶颈以及react如何应对" tabindex="-1">Diff的瓶颈以及React如何应对 <a class="header-anchor" href="#diff的瓶颈以及react如何应对" aria-label="Permalink to &quot;Diff的瓶颈以及React如何应对&quot;">​</a></h3><p>由于Diff操作本身也会带来性能损耗，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n^3)，其中n是树中元素的数量。开销过于高昂。</p><p>因此React的diff会预设3个限制：</p><ol><li><strong>只对同级元素进行Diff</strong>。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。</li><li><strong>两个不同类型的元素会产生出不同的树</strong>。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。</li><li>开发者可以通过 <code>key prop</code>来暗示哪些子元素在不同的渲染下能保持稳定。</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 更新前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ka</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h3</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">song</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h3</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 更新后</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h3</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">song</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h3</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ka</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变p。这符合限制2的设定，会<strong>销毁并新建</strong>。</p><p>但是当我们用key指明了节点前后对应关系后React知道<code>key === &quot;ka&quot;</code>的p在更新后还存在，所以DOM节点可以复用，只是需要交下顺序。</p><h3 id="diff是如何实现的" tabindex="-1">Diff是如何实现的 <a class="header-anchor" href="#diff是如何实现的" aria-label="Permalink to &quot;Diff是如何实现的&quot;">​</a></h3><p>我们从Diff的入口函数<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280" target="_blank" rel="noreferrer"><code>reconcileChildFibers</code></a>出发，该函数会根据newChild（即<strong>JSX对象</strong>）类型调用不同的处理函数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 根据newChild类型选择不同diff函数处理</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reconcileChildFibers</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">returnFiber</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">currentFirstChild</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">null</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">newChild</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isObject</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newChild</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">object</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newChild</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">isObject</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">newChild</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">$$typeof</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">REACT_ELEMENT_TYPE</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 调用 reconcileSingleElement 处理</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// // ...省略其他case</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newChild</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">string</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newChild</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">number</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 调用 reconcileSingleTextNode 处理</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">isArray</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newChild</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 调用 reconcileChildrenArray 处理</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 一些其他情况调用处理函数</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 以上都没有命中，删除节点</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">deleteRemainingChildren</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">returnFiber</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">currentFirstChild</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>我们可以从同级的节点数量将Diff分为两类：</p><ol><li>当newChild类型为object、number、string，代表同级只有一个节点</li><li>当newChild类型为Array，同级有多个节点</li></ol><h2 id="单节点diff" tabindex="-1">单节点diff <a class="header-anchor" href="#单节点diff" aria-label="Permalink to &quot;单节点diff&quot;">​</a></h2><p>单节点diff流程如下：</p><img src="`+p+`"><p>核心在于<strong>如何判断DOM节点是否可以复用？</strong></p><ol><li>React通过先判断key是否相同，如果<code>key</code>相同，再判断<code>type</code>是否相同，只有<strong>都</strong>相同时一个DOM节点才能复用。</li><li>key相同， <ol><li>type也相同表示可以复用，返回复用的fiber</li><li>type不相同。将该fiber及其兄弟fiber标记为删除</li></ol></li><li>key不同，将该fiber标记为删除<code>DELETION</code></li></ol><p>例题，判断如下JSX对象对应的DOM元素是否可以复用：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 习题1 更新前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 更新后</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 习题2 更新前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">xxx</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 更新后</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ooo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 习题3 更新前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">xxx</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 更新后</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ooo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 习题4 更新前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">xxx</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">ka song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 更新后</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">xxx</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">xiao bei</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><ul><li>习题1: 未设置key prop默认 key = null;，所以更新前后key相同，都为null，但是更新前type为div，更新后为p，type改变则<strong>不能复用</strong>。</li><li>习题2: 更新前后key改变，不需要再判断type，<strong>不能复用</strong>。</li><li>习题3: 更新前后key改变，不需要再判断type，<strong>不能复用</strong>。</li><li>习题4: 更新前后key与type都未改变，<strong>可以复用</strong>。children变化，DOM的子元素需要更新。</li></ul><h2 id="多节点diff" tabindex="-1">多节点Diff <a class="header-anchor" href="#多节点diff" aria-label="Permalink to &quot;多节点Diff&quot;">​</a></h2><p>需要处理的情况如下：</p><ol><li><p>节点更新：包括节点属性变化，节点类型变化等</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 之前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">before</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">// 之后 </span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">after</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 情况1 —— 节点属性变化</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> // 情况2 —— 节点类型更新</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></li><li><p>节点新增或减少</p></li><li><p>节点位置变化</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 之前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">   </span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">// 之后</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></li></ol><h3 id="diff思路" tabindex="-1">Diff思路 <a class="header-anchor" href="#diff思路" aria-label="Permalink to &quot;Diff思路&quot;">​</a></h3><p>在日常开发中，相较于新增和删除，<strong>更新</strong>组件发生的频率更高。所以Diff会<strong>优先</strong>判断当前节点是否属于更新。</p><blockquote><p>在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。</p><p>虽然本次更新的JSX对象 newChildren为数组形式，但是和newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表，即不支持双指针遍历。</p><p>即 newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较。</p><p>所以无法使用双指针优化。</p></blockquote><p>基于以上原因，<code>Diff</code>算法的整体逻辑会经历<strong>两轮遍历</strong>：</p><p>第一轮遍历：处理<strong>更新</strong>的节点。</p><p>第二轮遍历：处理剩下的不属于更新的节点。</p><h3 id="第一轮遍历" tabindex="-1">第一轮遍历 <a class="header-anchor" href="#第一轮遍历" aria-label="Permalink to &quot;第一轮遍历&quot;">​</a></h3><p><strong>过程如下：</strong></p><ol><li>let <code>i = 0</code>，遍历newChildren，将<code>newChildren[i]</code>与<code>oldFiber[i]</code>比较，判断DOM节点是否可复用。</li><li>如果<strong>可复用</strong>，<code>i++</code>，继续比较<code>newChildren[i]与oldFiber.sibling</code>(sibling表示兄弟节点)，可以复用则继续遍历。</li><li>如果<strong>不可复用</strong>，分两种情况 <ul><li><code>key</code>不同导致不可复用（属于“节点位置变化”的情况），立即跳出整个遍历，<strong>第一轮遍历结束</strong>。</li><li>key相同，但<code>type</code>不同导致不可复用，会创建一个新的fiber节点且标记为<code>Placement(插入)</code>，并将oldFiber标记为<code>DELETION</code>(删除)，并继续遍历</li></ul></li><li>如果newChildren遍历完(即i === newChildren.length - 1)或者oldFiber遍历完(oldFiber.sibling === null)，跳出遍历，<strong>第一轮遍历结束</strong>。</li></ol><p><strong>当第一轮遍历结束后，会有两种结果：</strong></p><ol><li><p>由步骤3跳出的遍历</p><p>此时<code>newChildren</code>没有遍历完，<code>oldFiber</code>也没有遍历完。</p><p>如下例：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 之前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 之后</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>第一个节点可复用，遍历到key === 2的节点发现key改变，不可复用，<strong>跳出遍历，等待第二轮遍历处理</strong>。</p><p>此时<code>oldFiber</code>剩下key === 1、key === 2未遍历，<code>newChildren</code>剩下key === 2、key === 1未遍历。</p></li><li><p>步骤4跳出的遍历</p><p>可能newChildren遍历完，或oldFiber遍历完，或他们同时遍历完。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 之前</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 之后 情况1 —— newChildren与oldFiber都遍历完</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">aa</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bb</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 之后 情况2 —— newChildren没遍历完，oldFiber遍历完</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// newChildren剩下 key===&quot;2&quot; 未遍历</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">aa</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bb</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">cc</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 之后 情况3 —— newChildren遍历完，oldFiber没遍历完</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// oldFiber剩下 key===&quot;1&quot; 未遍历</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">aa</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">0</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></li></ol><p><strong>总结</strong> 第一次遍历结束后，会有如下4种情况：</p><ol><li><p>newChildren与oldFiber同时遍历完</p></li><li><p>newChildren没遍历完，oldFiber遍历完：</p></li><li><p>newChildren遍历完，oldFiber没遍历完</p></li><li><p>newChildren与oldFiber都没遍历完</p></li></ol><h3 id="第二轮遍历" tabindex="-1">第二轮遍历 <a class="header-anchor" href="#第二轮遍历" aria-label="Permalink to &quot;第二轮遍历&quot;">​</a></h3><p>基于第一轮遍历结束后，产生的4种情况。进行第二轮遍历。</p><ol><li><p><code>newChildren</code>与<code>oldFiber</code>同时遍历完</p><p>是最理想的情况：只需在第一轮遍历进行组件更新。此时<strong>Diff结束</strong>。不进行第二次遍历。</p></li><li><p><code>newChildren</code>没遍历完，<code>oldFiber</code>遍历完：</p><p>意味着本次更新有<strong>新节点插入</strong></p><p><strong>第二次遍历</strong>的工作便是将剩下的newChildren为生成的workInProgress fiber依次标记<code>Placement</code>(插入)。</p></li><li><p><code>newChildren</code>遍历完，\`oldFiber没遍历完</p><p>意味着本次更新比之前的节点数量少，<strong>有节点被删除了</strong>。</p><p>所以<strong>第二次遍历</strong>的工作是将剩下的oldFiber，依次标记<code>Deletion</code>(删除)。</p></li><li><p><code>newChildren</code>与<code>oldFiber</code>都没遍历完</p><p>这意味着有节点在这次<strong>更新中改变了位置</strong>。这是Diff算法最精髓也是最难懂的部分。</p></li></ol><h4 id="分析newchildren与oldfiber都没遍历完的情况-处理移动的节点" tabindex="-1">分析<code>newChildren</code>与<code>oldFiber</code>都没遍历完的情况（处理移动的节点） <a class="header-anchor" href="#分析newchildren与oldfiber都没遍历完的情况-处理移动的节点" aria-label="Permalink to &quot;分析\`newChildren\`与\`oldFiber\`都没遍历完的情况（处理移动的节点）&quot;">​</a></h4><p>由于有节点在这次<strong>更新中改变了位置</strong>，所以不能再用位置索引<code>i</code>对比前后的节点，而要用到<code>key</code>。</p><p>为了快速的找到key对应的oldFiber，我们将所有还未处理的oldFiber存入<strong>以key为key，oldFiber为value的Map中</strong>。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> existingChildren </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">mapRemainingChildren</span><span style="color:#A6ACCD;">(returnFiber</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> oldFiber)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>接下来遍历剩余的newChildren，通过<code>newChildren[i].key</code>就能在existingChildren中找到key相同的<code>oldFiber</code>。</p><p>既然我们的目标是寻找移动的节点，那么我们需要明确：<strong>节点是否移动是以什么为参照物？</strong></p><p>我们的参照物是：<strong>最后一个可复用的节点在oldFiber中的位置索引</strong>（用变量<code>lastPlacedIndex</code>表示）。</p><p>用变量<code>oldIndex</code>表示当前遍历到的可复用节点在oldFiber中的位置索引。</p><ul><li><code>if(oldIndex &gt;= lastPlacedIndex)</code>，代表该可复用节点不需要移动，并执行<code>lastPlacedIndex = oldIndex</code>语句</li><li><code>if(oldIndex &lt; lastPlacedIndex)</code>，代表本次更新该节点需要向右移动。</li></ul><p>...单纯文字表达比较晦涩，跟着下面两个Demo对照着理解。</p><p>例子一:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 之前</span></span>
<span class="line"><span style="color:#A6ACCD;">abcd</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 之后</span></span>
<span class="line"><span style="color:#A6ACCD;">acdb</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第一轮遍历开始</span><span style="color:#89DDFF;">===</span></span>
<span class="line"><span style="color:#A6ACCD;">a（之后）vs a（之前）  </span></span>
<span class="line"><span style="color:#A6ACCD;">key不变，可复用</span></span>
<span class="line"><span style="color:#A6ACCD;">此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为0</span></span>
<span class="line"><span style="color:#A6ACCD;">所以 lastPlacedIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续第一轮遍历</span><span style="color:#89DDFF;">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">c（之后）vs b（之前）  </span></span>
<span class="line"><span style="color:#A6ACCD;">key改变，不能复用，跳出第一轮遍历</span></span>
<span class="line"><span style="color:#A6ACCD;">此时 lastPlacedIndex </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第一轮遍历结束</span><span style="color:#89DDFF;">===</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第二轮遍历开始</span><span style="color:#89DDFF;">===</span></span>
<span class="line"><span style="color:#A6ACCD;">newChildren </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> cdb，没用完，不需要执行删除旧节点</span></span>
<span class="line"><span style="color:#A6ACCD;">oldFiber </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> bcd，没用完，不需要执行插入新节点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">将剩余oldFiber（bcd）保存为map</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前oldFiber：bcd</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前newChildren：cdb</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续遍历剩余newChildren</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> c 在 oldFiber中存在</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> oldIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> c（之前）</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">此时 oldIndex </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 之前节点为 abcd，所以c.index === 2</span></span>
<span class="line"><span style="color:#A6ACCD;">比较 oldIndex 与 lastPlacedIndex</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">如果 oldIndex </span><span style="color:#89DDFF;">&gt;=</span><span style="color:#A6ACCD;"> lastPlacedIndex 代表该可复用节点不需要移动</span></span>
<span class="line"><span style="color:#A6ACCD;">并将 lastPlacedIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> oldIndex</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">如果 oldIndex </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">在例子中，oldIndex </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> lastPlacedIndex </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">，</span></span>
<span class="line"><span style="color:#A6ACCD;">则 lastPlacedIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">c节点位置不变</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续遍历剩余newChildren</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前oldFiber：bd</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前newChildren：db</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> d 在 oldFiber中存在</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> oldIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> d（之前）</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">oldIndex </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> lastPlacedIndex </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 之前节点为 abcd，所以d.index === 3</span></span>
<span class="line"><span style="color:#A6ACCD;">则 lastPlacedIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">d节点位置不变</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续遍历剩余newChildren</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前oldFiber：b</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前newChildren：b</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> b 在 oldFiber中存在</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> oldIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> b（之前）</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">oldIndex </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> lastPlacedIndex </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 之前节点为 abcd，所以b.index === 1</span></span>
<span class="line"><span style="color:#A6ACCD;">则 b节点需要</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">向右</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">移动</span></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第二轮遍历结束</span><span style="color:#89DDFF;">===</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">最终acd 3个节点都没有移动，b节点被标记为移动。 </span><span style="color:#676E95;font-style:italic;">// 怎么确定b移动到哪里去呢？</span></span></code></pre></div><p>例子2:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 之前</span></span>
<span class="line"><span style="color:#A6ACCD;">abcd</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 之后</span></span>
<span class="line"><span style="color:#A6ACCD;">dabc</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第一轮遍历开始</span><span style="color:#89DDFF;">===</span></span>
<span class="line"><span style="color:#A6ACCD;">d（之后）vs a（之前）  </span></span>
<span class="line"><span style="color:#A6ACCD;">key改变，不能复用，跳出遍历</span></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第一轮遍历结束</span><span style="color:#89DDFF;">===</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第二轮遍历开始</span><span style="color:#89DDFF;">===</span></span>
<span class="line"><span style="color:#A6ACCD;">newChildren </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> dabc，没用完，不需要执行删除旧节点</span></span>
<span class="line"><span style="color:#A6ACCD;">oldFiber </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> abcd，没用完，不需要执行插入新节点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">将剩余oldFiber（abcd）保存为map</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续遍历剩余newChildren</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前oldFiber：abcd</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前newChildren dabc</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> d 在 oldFiber中存在</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> oldIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> d（之前）</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">此时 oldIndex </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 之前节点为 abcd，所以d.index === 3</span></span>
<span class="line"><span style="color:#A6ACCD;">oldIndex </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> lastPlacedIndex </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">所以d节点位置不变，且执行lastPlacedIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续遍历剩余newChildren</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前oldFiber：abc</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前newChildren abc</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> a 在 oldFiber中存在</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> oldIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a（之前）</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 之前节点为 abcd，所以a.index === 0</span></span>
<span class="line"><span style="color:#A6ACCD;">此时 oldIndex </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">oldIndex </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> lastPlacedIndex </span><span style="color:#F78C6C;">3</span></span>
<span class="line"><span style="color:#A6ACCD;">所以 a节点需要</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">向右</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">移动</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续遍历剩余newChildren</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前oldFiber：bc</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前newChildren bc</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> b 在 oldFiber中存在</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> oldIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> b（之前）</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 之前节点为 abcd，所以b.index === 1</span></span>
<span class="line"><span style="color:#A6ACCD;">此时 oldIndex </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">oldIndex </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> lastPlacedIndex </span><span style="color:#F78C6C;">3</span></span>
<span class="line"><span style="color:#A6ACCD;">所以 b节点需要</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">向右</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">移动</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">继续遍历剩余newChildren</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前oldFiber：c</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 当前newChildren c</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> c 在 oldFiber中存在</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> oldIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> c（之前）</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 之前节点为 abcd，所以c.index === 2</span></span>
<span class="line"><span style="color:#A6ACCD;">此时 oldIndex </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">oldIndex </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> lastPlacedIndex </span><span style="color:#F78C6C;">3</span></span>
<span class="line"><span style="color:#A6ACCD;">则 c节点需要</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">向右</span><span style="color:#89DDFF;">**</span><span style="color:#A6ACCD;">移动</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">第二轮遍历结束</span><span style="color:#89DDFF;">===</span></span></code></pre></div><p>可以看到，我们以为从 abcd 变为 dabc，只需要将d<strong>向左</strong>移动到前面。</p><p>但实际上React<strong>保持d不变</strong>，将abc分别<strong>向右</strong>移动到了d的后面。</p><p>从这点可以看出，<strong>考虑性能</strong>，我们要尽量减少将节点从后面移动到前面的操作。(⭐<strong>React性能优化Tips</strong>)</p>`,64),t=[e];function c(r,D,y,F,i,C){return n(),l("div",null,t)}const f=s(o,[["render",c]]);export{d as __pageData,f as default};
