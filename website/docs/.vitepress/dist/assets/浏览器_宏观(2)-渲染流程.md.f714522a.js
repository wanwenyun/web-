import{_ as e,o as a,c as t,V as o}from"./chunks/framework.75331a37.js";const r="/assets/pic8.042bfa85.png",i="/assets/pic9.ffab6d52.png",l="/assets/pic10.6b26d610.png",s="/assets/pic11.9a40394d.png",d="/assets/pic12.93482a13.png",n="/assets/pic13.2b4e909c.png",c="/assets/pic14.a608b38a.png",h="/assets/pic15.1b4f5c90.png",p="/assets/summer.5cbe3ce7.png",P=JSON.parse('{"title":"渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/宏观(2)-渲染流程.md","filePath":"浏览器/宏观(2)-渲染流程.md"}'),m={name:"浏览器/宏观(2)-渲染流程.md"},u=o('<ul><li><a href="#渲染流程">渲染流程</a><ul><li><a href="#构建dom树">构建DOM树</a></li><li><a href="#样式计算">样式计算</a></li><li><a href="#布局阶段">布局阶段</a><ul><li><a href="#创建布局树">创建布局树</a></li><li><a href="#布局计算">布局计算</a></li></ul></li><li><a href="#分层">分层</a></li><li><a href="#图层绘制">图层绘制</a></li><li><a href="#栅格化raster操作">栅格化（raster）操作</a></li><li><a href="#合成和显示">合成和显示</a></li></ul></li><li><a href="#渲染流程总结-star">渲染流程总结 ⭐</a></li><li><a href="#相关概念">相关概念</a><ul><li><a href="#重排更新了元素的几何属性">重排（更新了元素的几何属性）</a></li><li><a href="#重绘更新元素的绘制属">重绘（更新元素的绘制属）</a></li><li><a href="#合成">合成</a></li><li><a href="#如何减少重排和重绘">如何减少重排和重绘？</a></li></ul></li></ul><blockquote><p><a href="https://time.geekbang.org/column/article/118205?utm_term=zeusQYFJN&amp;utm_source=app&amp;utm_medium=geektime&amp;utm_campaign=216-end&amp;utm_content=v8zhuanlankaipianci0316" target="_blank" rel="noreferrer">参考链接1</a></p><p><a href="https://time.geekbang.org/column/article/118826?utm_term=zeusQYFJN&amp;utm_source=app&amp;utm_medium=geektime&amp;utm_campaign=216-end&amp;utm_content=v8zhuanlankaipianci0316" target="_blank" rel="noreferrer">参考链接2</a></p></blockquote><h1 id="渲染流程" tabindex="-1">渲染流程 <a class="header-anchor" href="#渲染流程" aria-label="Permalink to &quot;渲染流程&quot;">​</a></h1><p>通常，我们编写好 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面。</p><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出<strong>像素</strong>。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p><img src="'+r+'" width="70%/"><p>流水线可分为如下几个子阶段：<code>构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</code>。</p><blockquote><p>PS：<strong>渲染树</strong>是16年之前的东西了，现在的代码完全重构了，所以本文讲的都是<code>新</code>的东西</p></blockquote><h2 id="构建dom树" tabindex="-1">构建DOM树 <a class="header-anchor" href="#构建dom树" aria-label="Permalink to &quot;构建DOM树&quot;">​</a></h2><p>这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——<code>DOM 树</code>。</p><img src="'+i+'"><p>构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p><table><thead><tr><th>输入</th><th>处理</th><th>输出</th></tr></thead><tbody><tr><td>HTML文档</td><td>HTML 解析器解析</td><td>DOM树</td></tr></tbody></table><h2 id="样式计算" tabindex="-1">样式计算 <a class="header-anchor" href="#样式计算" aria-label="Permalink to &quot;样式计算&quot;">​</a></h2><p>css样式来源有三种</p><img src="'+l+'" width="70%/"><p>样式计算的目的是为了计算出 <strong>DOM 节点中每个元素的具体样式</strong>，这个阶段大体可分为三步来完成。</p><ol><li><p>把 CSS 转换为浏览器能够理解的结构</p><p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——<code>styleSheets</code>。</p><blockquote><p>可在浏览器控制台通过<code>document.styleSheets</code>查看styleSheets结构</p></blockquote></li><li><p>转换样式表中的属性值，使其标准化</p><p>CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以<strong>需要将所有值转换为渲染引擎容易理解的、标准化的计算值</strong>，这个过程就是属性值标准化。</p><img src="'+s+'" width="70%/"></li><li><p>计算出 DOM 树中每个节点的具体样式 现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性。</p><p>这里涉及到 CSS 的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance" target="_blank" rel="noreferrer"><code>继承规则</code>和<code>层叠规则</code></a>。</p><ul><li>继承：每个 DOM 节点都包含有父节点的样式</li><li>层叠：</li></ul></li></ol><p>最终得到</p><table><thead><tr><th>输入</th><th>处理</th><th>输出</th></tr></thead><tbody><tr><td>CSS文本</td><td>1. 转styleSheets，2. 属性值标准化，3. 计算每个节点具体样式（继承、层叠）</td><td>styleSheets</td></tr></tbody></table><h2 id="布局阶段" tabindex="-1">布局阶段 <a class="header-anchor" href="#布局阶段" aria-label="Permalink to &quot;布局阶段&quot;">​</a></h2><p>有了 <code>DOM 树</code>和 <code>DOM 树中元素的样式</code>之后，就需要计算出 DOM 树中可见元素的<strong>几何位置</strong>，我们把这个计算过程叫做<code>布局</code>。</p><p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p><h3 id="创建布局树" tabindex="-1">创建布局树 <a class="header-anchor" href="#创建布局树" aria-label="Permalink to &quot;创建布局树&quot;">​</a></h3><p>DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵<strong>只包含可见元素布局树</strong>。</p><img src="'+d+'" width="70%/"><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p><ul><li>遍历 DOM 树中的所有<strong>可见</strong>节点，并把这些节点加到布局树中；</li><li>而<strong>不可见</strong>的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li></ul><h3 id="布局计算" tabindex="-1">布局计算 <a class="header-anchor" href="#布局计算" aria-label="Permalink to &quot;布局计算&quot;">​</a></h3><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。</p><h2 id="分层" tabindex="-1">分层 <a class="header-anchor" href="#分层" aria-label="Permalink to &quot;分层&quot;">​</a></h2><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，但接下来依然不是绘制页面。</p><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<code>图层树（LayerTree）</code>。</p><img src="'+n+'" width="60%/"><p>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。这些图层和布局树节点之间的关系，如文中图所示：</p><img src="'+c+'" width="60%/"><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><p>通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p><ul><li>拥有<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noreferrer">层叠上下文属性</a>（比如：flex,position,grid等）的元素会被提升为单独的一层。</li><li>需要剪裁（比如，内容超出容器大小）的地方也会被创建为图层。</li></ul><h2 id="图层绘制" tabindex="-1">图层绘制 <a class="header-anchor" href="#图层绘制" aria-label="Permalink to &quot;图层绘制&quot;">​</a></h2><p>渲染引擎会把一个图层的绘制拆分成很多小的<code>绘制指令</code>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p><img src="'+h+'" width="70%/"><h2 id="栅格化-raster-操作" tabindex="-1">栅格化（raster）操作 <a class="header-anchor" href="#栅格化-raster-操作" aria-label="Permalink to &quot;栅格化（raster）操作&quot;">​</a></h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由<strong>渲染引擎中的合成线程</strong>来完成的。</p><p>合成线程会将较大、较长的图层（一屏显示不完，大部分不在视口内）划<strong>分为图块</strong>（tile, 256<em>256, 512</em>512）。</p><p>所谓<strong>栅格化，是指将图块转换为位图</strong>。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。栅格化过程都会使用 <strong>GPU</strong> 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><h2 id="合成和显示" tabindex="-1">合成和显示 <a class="header-anchor" href="#合成和显示" aria-label="Permalink to &quot;合成和显示&quot;">​</a></h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给<strong>浏览器进程</strong>。根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><h1 id="渲染流程总结" tabindex="-1">渲染流程总结 ⭐ <a class="header-anchor" href="#渲染流程总结" aria-label="Permalink to &quot;渲染流程总结 :star:&quot;">​</a></h1><img src="'+p+'"><ol><li>渲染进程将 HTML 内容转换为能够读懂的<code>DOM 树</code>结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <code>styleSheets</code>，计算出 DOM 节点的样式。</li><li>创建<code>布局树</code>，并计算元素的布局信息。</li><li>对布局树进行分层，并生成<code>分层树</code>。</li><li>为每个图层生成<code>绘制列表</code>，并将其提交到合成线程。</li><li>合成线程将图层分成<code>图块</code>，并在<code>光栅化线程池</code>中将图块转换成位图。</li><li>合成线程发送绘制图块命令 <code>DrawQuad</code> 给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息<code>生成页面</code>，并<code>显示</code>到显示器上。</li></ol><h1 id="相关概念" tabindex="-1">相关概念 <a class="header-anchor" href="#相关概念" aria-label="Permalink to &quot;相关概念&quot;">​</a></h1><h2 id="重排-更新了元素的几何属性" tabindex="-1">重排（更新了元素的几何属性） <a class="header-anchor" href="#重排-更新了元素的几何属性" aria-label="Permalink to &quot;重排（更新了元素的几何属性）&quot;">​</a></h2><ol><li>更新了元素的几何属性（如<strong>宽、高、边距</strong>）；</li><li>触发<strong>重新布局</strong>，解析之后的一系列子阶段；</li><li>更新完成的渲染流水线，开销最大。</li></ol><h2 id="重绘-更新元素的绘制属" tabindex="-1">重绘（更新元素的绘制属） <a class="header-anchor" href="#重绘-更新元素的绘制属" aria-label="Permalink to &quot;重绘（更新元素的绘制属）&quot;">​</a></h2><ol><li>更新元素的绘制属性（元素的<strong>颜色、背景色、边框</strong>等）；</li><li>布局阶段不会执行（无几何位置变换），直接进入绘制阶段。</li></ol><h2 id="合成" tabindex="-1">合成 <a class="header-anchor" href="#合成" aria-label="Permalink to &quot;合成&quot;">​</a></h2><p>如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<code>合成</code>。</p><p>比如使用了 CSS 的<code>transform</code>来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p><h2 id="如何减少重排和重绘" tabindex="-1">如何减少重排和重绘？ <a class="header-anchor" href="#如何减少重排和重绘" aria-label="Permalink to &quot;如何减少重排和重绘？&quot;">​</a></h2><ol><li>使用 class 操作样式，而不是频繁操作 style</li><li>避免使用 table 布局</li><li>批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React</li><li>Debounce window resize 事件</li><li>对 dom 属性的读写要分离</li><li>will-change: transform 做优化，等</li></ol>',61),_=[u];function g(b,f,S,q,k,M){return a(),t("div",null,_)}const x=e(m,[["render",g]]);export{P as __pageData,x as default};
