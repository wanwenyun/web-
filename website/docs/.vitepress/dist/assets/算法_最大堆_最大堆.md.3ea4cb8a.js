import{_ as s,o as t,c as e,d as o}from"./app.8cb9dc40.js";const i="/assets/Maxpq.eb8e9862.png",r="/assets/Maxpq-swim.346efb79.gif",a="/assets/Maxpq-sink.83c0cdae.gif",c="/assets/Maxpq-insert.81c51606.gif",_="/assets/Maxpq-delete.99225519.gif",k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"算法/最大堆/最大堆.md"}'),n={name:"算法/最大堆/最大堆.md"},p=o('<p><code>最大堆</code>: 本质上是个完全二叉树，只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针。 且每个节点都大于等于它的两个子节点</p><p>画个图就能理解了，比如 arr 是一个字符数组，注意数组的第一个索引 0 空着不用： <img src="'+i+'" alt="img"></p><p>将<code>arr[1]</code>作为整颗树的根，每个节点的父节点和左右孩子的<code>索引</code>都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p><p>除了基础的left, right, parent, exch(交换两元素), less(比较两元素大小)这几个基础的方法之外，还有四个关键的方法: swim(上浮), sink(下沉), insert(插入), delMax(删除并返回最大元素)</p><ol><li><p><strong>上浮(swim)的过程示意图：</strong><img src="'+r+'" alt="img"></p></li><li><p><strong>下沉(sink)的过程示意图：</strong><img src="'+a+'" alt="img"></p></li><li><p><strong>插入：</strong> insert 方法先把要插入的元素添加到堆底的最后，然后让其<code>上浮</code>到正确位置 <img src="'+c+'" alt="img"></p></li><li><p><strong>删除最大元素：</strong> delMax 方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B <code>下沉</code>到正确位置。 <img src="'+_+'" alt="img"></p></li></ol>',5),l=[p];function d(m,g,f,x,h,M){return t(),e("div",null,l)}const q=s(n,[["render",d]]);export{k as __pageData,q as default};
