import{_ as a,o as t,c as e,V as o}from"./chunks/framework.75331a37.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"算法/动态规划/index.md","filePath":"算法/动态规划/index.md"}'),i={name:"算法/动态规划/index.md"},l=o('<h2 id="什么是动态规划" tabindex="-1">什么是动态规划 <a class="header-anchor" href="#什么是动态规划" aria-label="Permalink to &quot;什么是动态规划&quot;">​</a></h2><p>动态规划，英文：Dynamic Programming，简称DP，将问题分解为<strong>互相重叠的子问题</strong>，通过反复求解子问题来解决原问题就是动态规划，如果某一问题有很多重叠子问题，使用动态规划来解是比较有效的。</p><p>求解动态规划的核心问题是穷举，但是这类问题穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下。动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的状态转移方程</strong>才能正确地穷举。<strong>重叠子问题、最优子结构、状态转移方程</strong>就是动态规划三要素。</p><h2 id="动态规划和其他算法的区别" tabindex="-1">动态规划和其他算法的区别 <a class="header-anchor" href="#动态规划和其他算法的区别" aria-label="Permalink to &quot;动态规划和其他算法的区别&quot;">​</a></h2><ol><li>动态规划和分治的区别：动态规划和分治都有最优子结构 ，但是分治的子问题不重叠</li><li>动态规划和贪心的区别：动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有<strong>状态推导</strong>，而是从局部直接选最优解，所以它永远是局部最优，但是全局的解不一定是最优的。</li><li>动态规划和递归的区别：递归和回溯可能存在非常多的重复计算，动态规划可以用<strong>递归 + 记忆化</strong>的方式减少不必要的重复计算</li></ol><h2 id="动态规划的解题方法" tabindex="-1">动态规划的解题方法 <a class="header-anchor" href="#动态规划的解题方法" aria-label="Permalink to &quot;动态规划的解题方法&quot;">​</a></h2><ol><li>递归+记忆化(自顶向下)</li><li>动态规划（自底向上）</li></ol><h2 id="解动态规划题目的步骤" tabindex="-1">解动态规划题目的步骤 <a class="header-anchor" href="#解动态规划题目的步骤" aria-label="Permalink to &quot;解动态规划题目的步骤&quot;">​</a></h2><ol><li>根据重叠子问题定义状态</li><li>寻找最优子结构推导状态转移方程， 确定dp初始状态</li><li>确定输出值</li></ol><p>东哥的动态规划解题思路 <strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong></p><p>常见题型</p><ol><li>路径问题</li><li>最长子序列</li></ol>',12),r=[l];function n(s,d,c,_,h,p){return t(),e("div",null,r)}const u=a(i,[["render",n]]);export{m as __pageData,u as default};
