import{_ as e,o as s,c as a,V as l}from"./chunks/framework.75331a37.js";const o="/assets/stack.6aa14675.png",n="/assets/pic1.7f2f7388.png",c="/assets/pic2.a2a989cc.png",r="/assets/pic3.84656cf0.png",t="/assets/pic4.0cdd3341.png",p="/assets/pic5.96959445.png",i="/assets/pic6.b6aa23eb.png",d="/assets/pic7.74699084.png",F="/assets/pic8.b570d550.png",_=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端框架/React/React核心原理/React核心原理1-理念(React15、fiber架构).md","filePath":"前端框架/React/React核心原理/React核心原理1-理念(React15、fiber架构).md"}'),D={name:"前端框架/React/React核心原理/React核心原理1-理念(React15、fiber架构).md"},y=l('<ul><li><a href="#前言">前言</a></li><li><a href="#react理念">React理念</a></li><li><a href="#老react架构---react-15">老React架构 - React 15</a></li><li><a href="#新react架构---react16">新React架构 - React16</a><ul><li><a href="#scheduler调度器">Scheduler（调度器）</a></li><li><a href="#reconciler协调器render阶段">Reconciler（协调器）render阶段</a></li><li><a href="#render渲染器commit阶段">Render（渲染器）commit阶段</a></li><li><a href="#例子">例子</a></li><li><a href="#总结-heavy_exclamation_mark">总结 :heavy_exclamation_mark:</a></li></ul></li><li><a href="#react16协调器render阶段架构----fiber">React16协调器(render阶段)架构 -- Fiber</a><ul><li><a href="#fiber架构的心智模型">Fiber架构的心智模型</a></li><li><a href="#fiber的三层含义">Fiber的三层含义</a><ul><li><a href="#架构层面">架构层面</a></li><li><a href="#作为静态的数据结构">作为静态的数据结构</a></li><li><a href="#作为动态的工作单元">作为动态的工作单元</a></li></ul></li><li><a href="#fiber架构的工作原理---双缓存-heavy_exclamation_mark">Fiber架构的工作原理 - 双缓存 :heavy_exclamation_mark:</a><ul><li><a href="#怎么理解双缓存">怎么理解双缓存</a></li><li><a href="#fiber架构双缓存">Fiber架构双缓存</a></li></ul></li></ul></li><li><a href="#总结">总结</a></li><li><a href="#react源码如何调试">react源码如何调试？</a></li></ul><blockquote><p>参考资料：React技术揭秘：<a href="https://react.iamkasong.com/preparation/idea.html#react%E7%90%86%E5%BF%B5" target="_blank" rel="noreferrer">https://react.iamkasong.com/preparation/idea.html#react理念</a></p></blockquote><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>React入口函数，<code>ReactDom.render(&lt;p&gt;hello world&lt;/p&gt;, root)</code></p><p>调用栈： <img src="'+o+`"></p><h2 id="react理念" tabindex="-1">React理念 <a class="header-anchor" href="#react理念" aria-label="Permalink to &quot;React理念&quot;">​</a></h2><p>React理念是：构建<strong>快速响应</strong>的大型 Web 应用程序。</p><p>但由于以下两个瓶颈会制约应用的响应速度：</p><ol><li><strong>CPU瓶颈</strong>：当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。</li><li><strong>IO瓶颈</strong>：发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</li></ol><p>React应对这两大瓶颈的办法是：努力将同步的更新变为<code>可中断的异步</code>更新。❤️</p><h2 id="老react架构-react-15" tabindex="-1">老React架构 - React 15 <a class="header-anchor" href="#老react架构-react-15" aria-label="Permalink to &quot;老React架构 - React 15&quot;">​</a></h2><p>React15架构可以分为两层：</p><ul><li><code>Reconciler（协调器）</code>—— 负责找出变化的组件，diff算法。<strong>递归</strong>处理虚拟DOM。</li><li><code>Renderer（渲染器）</code>—— 负责将变化的组件渲染到页面上，包括DOM节点的增、删、查、改。 <ul><li><code>浏览器</code>环境渲染的Renderer</li><li>ReactNative渲染器，渲染App原生组件</li><li>ReactTest渲染器，渲染出纯Js对象用于测试</li><li>ReactArt渲染器，渲染到Canvas, SVG 或 VML (IE8)</li></ul></li></ul><p>React15的缺点</p><ul><li>协调器和渲染器依次执行工作，</li><li>更新的过程是同步的。</li><li>当子组件更新一旦开始，中途就无法中断</li><li>当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。</li></ul><h2 id="新react架构-react16" tabindex="-1">新React架构 - React16 <a class="header-anchor" href="#新react架构-react16" aria-label="Permalink to &quot;新React架构 - React16&quot;">​</a></h2><p>React16架构可以分为三层：</p><ul><li><code>Scheduler（调度器）</code>—— 调度任务的优先级，高优任务优先进入Reconciler。📌</li><li><code>Reconciler（协调器）</code>—— 负责找出变化的组件 📌</li><li><code>Renderer（渲染器）</code>—— 负责将变化的组件渲染到页面上</li></ul><p><strong>可以看到，相较于React15，React16中新增了Scheduler（调度器），让我们来了解下他。</strong></p><h3 id="scheduler-调度器" tabindex="-1">Scheduler（调度器） <a class="header-anchor" href="#scheduler-调度器" aria-label="Permalink to &quot;Scheduler（调度器）&quot;">​</a></h3><p>React实现了功能更完备的<code>requestIdleCallback</code>polyfill，这就是<code>Scheduler</code>。会在浏览器空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。</p><blockquote><p>部分浏览器已经实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noreferrer">requestIdleCallback</a>这个API，但存在兼容性问题；并且该方法的触发受很多因素影响，所以不稳定。 Scheduler是独立于React的库</p></blockquote><h3 id="reconciler-协调器-render阶段" tabindex="-1">Reconciler（协调器）render阶段 <a class="header-anchor" href="#reconciler-协调器-render阶段" aria-label="Permalink to &quot;Reconciler（协调器）render阶段&quot;">​</a></h3><p>在React15中Reconciler是递归处理虚拟DOM的。在React16中，更新工作从递归变成了可以<code>中断</code>的<code>循环</code>过程。每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">workLoopConcurrent</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// Perform work until Scheduler asks us to yield</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">shouldYield</span><span style="color:#F07178;">()) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p><strong>那么React16是如何解决中断更新时DOM渲染不完全的问题呢？</strong></p><ul><li>在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表<code>增/删/更新</code>的标记</li><li>整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。</li></ul><p>Reconciler内部采用了<code>Fiber</code>的架构。❗</p><h3 id="render-渲染器-commit阶段" tabindex="-1">Render（渲染器）commit阶段 <a class="header-anchor" href="#render-渲染器-commit阶段" aria-label="Permalink to &quot;Render（渲染器）commit阶段&quot;">​</a></h3><p>Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。</p><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><ul><li><p>假设有三个更新，优先级依次为低、中、高。</p></li><li><p>当前已有<code>更新1</code>和<code>更新2</code>。由于<code>更新2</code>的优先级更高，所以协调器优先处理<code>更新2</code>。</p></li><li><p>当协调器在处理<code>更新2</code>的过程中，产生了<code>更新3</code>。那么<code>更新2</code>会被中断，协调器优先处理<code>更新3</code></p><img src="`+n+'" width="49%"><img src="'+c+'" width="49%"></li><li><p>由于调度器和协调器都是在内存中进行，不会执行具体的视图操作，所以，即使有被中断的更新，用户也不会看到更新不完全的视图。</p></li><li><p>当协调器完成了某次更新的工作，协调器会通知渲染器执行对应的视图操作</p><img src="'+r+'" width="49%"></li><li><p>当高优先级的更新最终完成了渲染，调度器又会开始新一轮的调度</p><img src="'+t+'" width="49%"></li></ul><img src="'+p+`" width="90%"><p>其中红框中的步骤随时可能由于以下原因被中断：</p><ul><li>有其他更高优任务需要先更新</li><li>当前帧没有剩余时间</li></ul><p>由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM。</p><h3 id="总结" tabindex="-1">总结 ❗ <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结 :heavy_exclamation_mark:&quot;">​</a></h3><ul><li>React16采用<code>Scheduler（调度器）</code>和<code>新的Reconcile(协调器)</code></li><li>Scheduler（调度器）会在浏览器空闲时触发回调的功能，还会执行其他操作。</li><li>Reconciler(协调器)内部采用了<code>Fiber</code>的架构。目的是为了实现将<strong>同步</strong>的更新变为<strong>可中断的异步</strong>更新。</li><li>Scheduler（调度器）和 Reconcile(协调器)的工作不会被用户看见。只有Render（渲染器）会更新页面上的Dom。所以，即使有被中断的更新，用户也不会看到更新不完全的视图。</li></ul><h2 id="react16协调器-render阶段-架构-fiber" tabindex="-1">React16协调器(render阶段)架构 -- Fiber <a class="header-anchor" href="#react16协调器-render阶段-架构-fiber" aria-label="Permalink to &quot;React16协调器(render阶段)架构 -- Fiber&quot;">​</a></h2><p>React16<strong>协调器</strong>采用了<code>Fiber架构</code>，实现了<code>异步的可中断更新</code>。</p><h3 id="fiber架构的心智模型" tabindex="-1">Fiber架构的心智模型 <a class="header-anchor" href="#fiber架构的心智模型" aria-label="Permalink to &quot;Fiber架构的心智模型&quot;">​</a></h3><p><a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/" target="_blank" rel="noreferrer"><strong>代数效应</strong></a>：是函数式编程中的一个概念，用于将副作用从函数调用中分离。也就是说能够将副作用从函数中逻辑中分离，使得函数关注点保持存粹。</p><p><strong>代数效应在React中的应用 - <code>Hooks</code></strong></p><p>对于类似useState、useReducer、useRef这样的Hook，我们不需要关注FunctionComponent的state在Hook中是如何保存的，React会为我们处理。</p><p><strong>代数效应和Generator：</strong></p><p>从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为<strong>异步可中断更新</strong>。 <code>异步可中断更新</code>可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。 其实，浏览器原生就支持类似的实现，这就是<code>Generator</code>。但是Generator的一些缺陷使React团队放弃了他：</p><ul><li>类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。</li><li>Generator执行的中间状态是上下文关联的。</li></ul><p><strong>代数效应与Fiber：</strong></p><ul><li><p>React内部实现的一套状态更新机制。支持任务不同<code>优先级</code>，可<code>中断与恢复</code>，并且恢复后可以复用之前的<code>中间状态</code>。</p></li><li><p>其中每个任务更新单元为<code>React Element</code>对应的<code>Fiber节点</code>。</p></li></ul><h3 id="fiber的三层含义" tabindex="-1">Fiber的三层含义 <a class="header-anchor" href="#fiber的三层含义" aria-label="Permalink to &quot;Fiber的三层含义&quot;">​</a></h3><ul><li><strong>架构</strong>层面，之前React15的Reconciler采用递归的方式执行，数据保存在<code>递归调用栈</code>中，所以被称为<code>stack Reconciler</code>。React16的Reconciler基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</li><li><strong>静态的数据结构</strong>层面，每个<code>Fiber节点</code>对应一个<code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的<code>DOM节点</code>等信息。</li><li><strong>动态的工作单元</strong>层面，每个Fiber节点保存了本次更新中该组件<code>需要更新的状态</code>、<code>需要执行的工作</code>（需要被删除/被插入页面中/被更新...）。</li></ul><p><strong>在React16中，虚拟DOM就是fiber节点</strong>❗</p><h4 id="架构层面" tabindex="-1">架构层面 <a class="header-anchor" href="#架构层面" aria-label="Permalink to &quot;架构层面&quot;">​</a></h4><p>每个<code>Fiber节点</code>有个对应的<code>React element</code>，多个Fiber节点是如何连接形成树呢？靠如下三个属性：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 指向父级Fiber节点</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">return </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 指向子Fiber节点</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">child </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 指向右边第一个兄弟Fiber节点</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">sibling </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span></code></pre></div><p>例子： <img src="`+i+`" width="90%"></p><h4 id="作为静态的数据结构" tabindex="-1">作为静态的数据结构 <a class="header-anchor" href="#作为静态的数据结构" aria-label="Permalink to &quot;作为静态的数据结构&quot;">​</a></h4><p>作为一种静态的数据结构，保存了组件相关的信息：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Fiber对应组件的类型 Function/Class/Host...</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">tag </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> tag</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// key属性</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">elementType </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">type </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Fiber对应的真实DOM节点</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">stateNode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span></code></pre></div><h4 id="作为动态的工作单元" tabindex="-1">作为动态的工作单元 <a class="header-anchor" href="#作为动态的工作单元" aria-label="Permalink to &quot;作为动态的工作单元&quot;">​</a></h4><p>作为<strong>动态的工作单元</strong>，每个Fiber节点保存了本次更新中该组件<code>需要更新的状态</code>、<code>需要执行的工作</code>（需要被删除/被插入页面中/被更新...）。Fiber中用如下参数保存了本次更新相关的信息，</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 保存本次更新造成的状态改变相关信息</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">pendingProps </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> pendingProps</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">memoizedProps </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">updateQueue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">memoizedState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">dependencies </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">mode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> mode</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 保存本次更新会造成的DOM操作</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">effectTag </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> NoEffect</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">nextEffect </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">firstEffect </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">lastEffect </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span></code></pre></div><h3 id="fiber架构的工作原理-双缓存" tabindex="-1">Fiber架构的工作原理 - 双缓存 ❗ <a class="header-anchor" href="#fiber架构的工作原理-双缓存" aria-label="Permalink to &quot;Fiber架构的工作原理 - 双缓存 :heavy_exclamation_mark:&quot;">​</a></h3><h4 id="怎么理解双缓存" tabindex="-1">怎么理解双缓存 <a class="header-anchor" href="#怎么理解双缓存" aria-label="Permalink to &quot;怎么理解双缓存&quot;">​</a></h4><p>当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。</p><p>如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。</p><p>为了解决这个问题，我们可以在<strong>内存</strong>中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。</p><p>这种在内存中构建并直接替换的技术叫做双缓存 (opens new window)。</p><h4 id="fiber架构双缓存" tabindex="-1">Fiber架构双缓存 <a class="header-anchor" href="#fiber架构双缓存" aria-label="Permalink to &quot;Fiber架构双缓存&quot;">​</a></h4><p>React使用<code>“双缓存”</code>来完成<code>Fiber树</code>的构建与替换 —— 对应着<code>DOM树</code>的创建与更新。</p><p>在React中最多会同时存在两棵Fiber树。</p><ul><li>当前屏幕上<code>显示内容</code>对应的Fiber树称为<code>current Fiber tree</code>，其对应节点为<code>current fiber</code></li><li><code>正在内存中构建</code>的Fiber树称为<code>workInProgress Fiber tree</code>，其对应节点为<code>workInProgress fiber</code></li></ul><p>两种节点通过<code>alternate</code>属性连接。</p><p>React应用的根节点通过使<code>current</code>指针在不同<code>Fiber树</code>的<code>rootFiber</code>间切换来完成current Fiber树指向的切换。</p><p>❗即当<code>workInProgress Fiber树</code>构建完成交给<code>Renderer</code>渲染在页面上后，应用根节点的<code>current</code>指针指向<code>workInProgress Fiber树</code>，此时<code>workInProgress Fiber树</code>就变为<code>current Fiber树</code>。</p><p><code>每次状态更新</code>都会产生<code>新</code>的workInProgress Fiber树，通过<code>current</code>与<code>workInProgress</code>的<code>替换</code>，完成<code>DOM</code>更新。</p><p>fiber树的<strong>构建/替换</strong>分为<code>mount时</code>， <code>update时</code>。</p><p>例子：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">num</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">add</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(num </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;{</span><span style="color:#A6ACCD;">num</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;">/&gt;,</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">root</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span></code></pre></div><ol><li><p><strong>mount</strong>构建时，</p><p>首次执行ReactDOM.render会创建fiberRootNode（源码中叫fiberRoot）和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是<code>&lt;App/&gt;</code>所在组件树的根节点。</p><img src="`+d+'" width="90%"></li><li><p><strong>update</strong>时，点击p标签 <img src="'+F+'" width="90%"></p></li></ol><h2 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>通过本章的学习，我们了解了React的<code>Scheduler(调度器)-Reconciler(协调器)-Renderer(渲染器)</code>架构体系</p><ul><li>Reconciler工作的阶段被称为<code>render阶段</code>。因为在该阶段会调用组件的render方法。</li><li>Renderer工作的阶段被称为<code>commit阶段</code>。就像你完成一个需求的编码后执行git commit提交代码。commit阶段会把render阶段提交的信息渲染在页面上。</li><li>render与commit阶段统称为<code>work</code>，即React在工作中。相对应的，如果任务正在Scheduler内调度，就不属于work。</li></ul><h2 id="react源码如何调试" tabindex="-1">react源码如何调试？ <a class="header-anchor" href="#react源码如何调试" aria-label="Permalink to &quot;react源码如何调试？&quot;">​</a></h2><p><a href="https://xiaochen1024.com/courseware/60b1b2f6cf10a4003b634718/60b1b32ecf10a4003b63471c" target="_blank" rel="noreferrer">参考步骤</a></p>',85),h=[y];function u(C,b,A,m,f,g){return s(),a("div",null,h)}const k=e(D,[["render",u]]);export{_ as __pageData,k as default};
