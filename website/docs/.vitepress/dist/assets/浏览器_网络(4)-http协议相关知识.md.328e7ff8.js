import{_ as l,o as e,c as t,V as o}from"./chunks/framework.75331a37.js";const u=JSON.parse('{"title":"HTTP各种请求方法","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/网络(4)-http协议相关知识.md","filePath":"浏览器/网络(4)-http协议相关知识.md"}'),i={name:"浏览器/网络(4)-http协议相关知识.md"},a=o('<ul><li><a href="#http各种请求方法">HTTP各种请求方法</a></li><li><a href="#get和post有什么区别">GET和POST有什么区别？</a></li><li><a href="#http状态码">HTTP状态码</a></li><li><a href="#url与uri">URL与URI</a></li></ul><h1 id="http各种请求方法" tabindex="-1">HTTP各种请求方法 <a class="header-anchor" href="#http各种请求方法" aria-label="Permalink to &quot;HTTP各种请求方法&quot;">​</a></h1><p>http/1.1规定了以下请求方法(注意，都是大写):</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 判断是否有请求权限，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h1 id="get和post有什么区别" tabindex="-1">GET和POST有什么区别？ <a class="header-anchor" href="#get和post有什么区别" aria-label="Permalink to &quot;GET和POST有什么区别？&quot;">​</a></h1><ul><li>从<code>缓存</code>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>从<code>参数</code>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li><li>从<code>TCP（本质区别）</code>的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)这会导致在传输层中出现两次TCP连接，对于TCP来说，通信次数越多可靠性越低，能在一次连接中传输完需要的消息是最可靠的。</li><li>从<code>编码</code>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li><li>从<code>传输数据大小</code>的角度，GET提交的数据大小有限制（注意：Http Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制，这个限制是特定的浏览器及服务器对它的限制）；POST方法提交的数据没有限制</li></ul><h1 id="http状态码" tabindex="-1">HTTP状态码 <a class="header-anchor" href="#http状态码" aria-label="Permalink to &quot;HTTP状态码&quot;">​</a></h1><p><strong>1xx - 信息提示</strong></p><ul><li>101 - 切换协议，服务器根据客户端的请求切换协议。</li></ul><p><strong>2xx - 成功</strong></p><ul><li>200 - ok，请求已成功被服务器接收、理解、并接受</li><li><code>204</code> - 服务器成功处理了请求，但没返回任何内容。（<code>预检请求</code>返回的响应代码）</li><li><code>206</code> - 服务器已经成功处理了<code>部分</code> GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现<code>断点续传</code>或者将一个大文档分解为多个下载段同时下载。</li></ul><p><strong>3xx - 重定向</strong></p><ul><li><code>304</code> - 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。（涉及到<code>协商缓存</code>）</li></ul><p><strong>4xx - 客户端错误</strong></p><p><strong>5xx - 服务器错误</strong></p><ul><li>502 - 服务器上的一个<code>错误网关</code> ，因此说它是无效的</li><li>503 - <code>服务不可用</code>，服务器由于维护或者负载过重未能应答。</li><li>504 - <code>网关超时</code>，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</li></ul><h1 id="url与uri" tabindex="-1">URL与URI <a class="header-anchor" href="#url与uri" aria-label="Permalink to &quot;URL与URI&quot;">​</a></h1><ul><li>URL是一种<strong>具体</strong>的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。</li><li>URI 是一种语义上的<strong>抽象概念</strong>，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</li></ul>',18),r=[a];function c(d,T,s,n,h,p){return e(),t("div",null,r)}const P=l(i,[["render",c]]);export{u as __pageData,P as default};
