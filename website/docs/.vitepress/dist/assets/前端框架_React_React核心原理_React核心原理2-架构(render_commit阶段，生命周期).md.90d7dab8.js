import{_ as s,o as n,c as a,V as o}from"./chunks/framework.75331a37.js";const e="/assets/lifeCycle.f8571c7a.png",l="/assets/reactRender.cb228ac9.png",p="/assets/beginWork.7b9f4e1d.png",t="/assets/completeWork.4557c553.png",u=JSON.parse('{"title":"React生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"前端框架/React/React核心原理/React核心原理2-架构(render,commit阶段，生命周期).md","filePath":"前端框架/React/React核心原理/React核心原理2-架构(render,commit阶段，生命周期).md"}'),c={name:"前端框架/React/React核心原理/React核心原理2-架构(render,commit阶段，生命周期).md"},r=o('<ul><li><a href="#react生命周期">React生命周期</a></li><li><a href="#专业术语解释-render阶段commit阶段等与总结-heavy_exclamation_mark">专业术语解释， render阶段、commit阶段等与总结 :heavy_exclamation_mark</a></li><li><a href="#render阶段-heavy_exclamation_mark">Render阶段 :heavy_exclamation_mark</a><ul><li><a href="#流程概览">流程概览</a><ul><li><a href="#递阶段----beginwork">“递”阶段 -- beginWork</a></li><li><a href="#归阶段----completework">“归”阶段 -- completeWork</a></li><li><a href="#例子">例子</a></li></ul></li><li><a href="#递阶段---beginwork">“递”阶段 - beginWork</a><ul><li><a href="#reconcilechildren">reconcileChildren</a></li><li><a href="#effecttag">effectTag</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#归阶段---completework">&quot;归&quot;阶段 - completeWork</a><ul><li><a href="#hostcomponen如何处理">HostComponen如何处理</a></li><li><a href="#effectlist"><code>effectList</code></a></li><li><a href="#总结-1">总结</a></li></ul></li></ul></li><li><a href="#commit阶段">commit阶段</a><ul><li><a href="#before-mutation阶段执行dom操作前">before mutation阶段（执行DOM操作前）</a></li><li><a href="#mutation阶段执行dom操作">mutation阶段（执行DOM操作）</a><ul><li><a href="#placement-effect">Placement effect</a></li><li><a href="#update-effect">Update effect</a></li><li><a href="#deletion-effect">Deletion effect</a></li></ul></li><li><a href="#layout阶段执行dom操作后">layout阶段（执行DOM操作后）</a></li></ul></li></ul><h1 id="react生命周期" tabindex="-1">React生命周期 <a class="header-anchor" href="#react生命周期" aria-label="Permalink to &quot;React生命周期&quot;">​</a></h1><img src="'+e+`"><h1 id="专业术语解释-render阶段、commit阶段等与总结-heavy-exclamation-mark" tabindex="-1">专业术语解释， render阶段、commit阶段等与总结 :heavy_exclamation_mark <a class="header-anchor" href="#专业术语解释-render阶段、commit阶段等与总结-heavy-exclamation-mark" aria-label="Permalink to &quot;专业术语解释， render阶段、commit阶段等与总结 :heavy_exclamation_mark&quot;">​</a></h1><p><a href="https://github.com/mbaxszy7/blog/issues/16" target="_blank" rel="noreferrer">参考链接</a></p><ul><li><strong>Render阶段 -- 确定更新细节</strong><ul><li><strong>在render阶段，React将</strong>更新<strong>应用于通过<code>setState或render</code>方法触发的组件，并确定需要在用户屏幕上做哪些更新--哪些节点需要插入，更新或删除，哪些组件需要调用其生命周期方法</strong>。</li><li>最终的这些更新信息被保存在一个叫<code>effect list</code>的<code>fiber</code> 节点树上</li><li>当然，在首次渲染时，React不需要产生任何更新信息，而是会给每个从render方法返回的element生成一个fiber节点，最终生成一个fiber节点树， 后续的更新也是复用了这棵fiber树。</li></ul></li><li><strong>Commit阶段 -- 将更新作用到Dom树上</strong><ul><li>在这个阶段时，React内部会有2个fiber树和一个list： <ol><li><code>current fiber tree</code>: 表示<code>显示内容</code>对应的Fiber树。在首次渲染时，React不需要产生任何更新信息，而是会给每个从render方法返回的element生成一个fiber节点，最终生成一个fiber节点树， 后续的更新也是复用了这棵fiber树。</li><li><code>workInProgress fiber tree</code>: 表示<code>正在内存中构建</code>的Fiber树。所有的更新计算工作都在workInProgress tree的fiber上执行。当React 遍历current fiber tree时，它为每个current fiber 创建一个替代（alternate）节点，这样的alternate节点构成了workInProgress tree</li><li><code>effect list</code>: 是workInProgress fiber tree 的子树，它的作用是串联了标记具有更新的节点</li></ol></li><li><strong>Commit阶段会遍历effect list，把所有更新都commit到<code>DOM树</code>上</strong>。具体如下 <ol><li>首先会有一个pre-commit阶段，主要是执行<code>getSnapshotBeforeUpdate</code>方法，可以获取当前DOM的快照（snap）</li><li>然后给需要卸载的组件执行componentWillUnmount方法</li><li>接着会把current fiber tree 替换为workInProgress fiber tree</li><li>最后执行DOM的插入、更新和删除，给更新的组件执行componentDidUpdate，给插入的组件执行componentDidMount</li></ol></li><li>重点要注意的是，这一阶段是<strong>同步执行的，不能中止</strong>。</li></ul></li></ul><hr><ul><li><code>Scheduler（调度器）</code>—— 调度任务的优先级，高优任务优先进入Reconciler。会在浏览器空闲时触发回调的功能，还会执行其他操作。Scheduler是一个独立于React的包</li><li><code>Reconciler（协调器）</code>—— <strong>负责找出变化的组件，确定更新细节</strong>。在此引用了<code>Fiber架构</code>，目的是为了实现将<strong>同步</strong>的更新变为<strong>可中断的异步</strong>更新。其工作的阶段被称为<code>render阶段</code>。因为在该阶段会调用组件的render方法。</li><li><code>Renderer（渲染器）</code>—— 负责将变化的组件渲染到页面上其工作的阶段被称为<code>commit阶段</code>。commit阶段会把render阶段提交的信息<strong>渲染</strong>在页面上。</li></ul><p>render与commit阶段统称为<code>work</code>，即React在工作中。相对应的，如果任务正在<code>Scheduler(调度器)</code>内调度，就不属于work。</p><h1 id="render阶段-heavy-exclamation-mark" tabindex="-1">Render阶段 :heavy_exclamation_mark <a class="header-anchor" href="#render阶段-heavy-exclamation-mark" aria-label="Permalink to &quot;Render阶段 :heavy_exclamation_mark&quot;">​</a></h1><p>本章我们会讲解<code>Fiber节点</code>是如何被创建并构建<code>Fiber树</code>的。</p><h2 id="流程概览" tabindex="-1">流程概览 <a class="header-anchor" href="#流程概览" aria-label="Permalink to &quot;流程概览&quot;">​</a></h2><p>在<code>render</code>阶段，React将更新应用于通过setState或render方法触发的组件，并确定需要在用户屏幕上做哪些更新--哪些节点需要插入，更新或删除，哪些组件需要调用其生命周期方法。</p><p><code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// performSyncWorkOnRoot会调用该方法</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">workLoopSync</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// performConcurrentWorkOnRoot会调用该方法</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">workLoopConcurrent</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">shouldYield</span><span style="color:#F07178;">()) </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历。</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p><code>performUnitOfWork</code>方法会创建下一个<code>Fiber节点</code>并赋值给<code>workInProgress</code>，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。</p><p>Fiber Reconciler(协调器)通过遍历的方式实现可中断的递归，所以<code>performUnitOfWork</code>的工作可以分为两部分：<code>“递”和“归”</code>。</p><h3 id="递-阶段-beginwork" tabindex="-1">“递”阶段 -- beginWork <a class="header-anchor" href="#递-阶段-beginwork" aria-label="Permalink to &quot;“递”阶段 -- beginWork&quot;">​</a></h3><ul><li>首先从<code>rootFiber</code>开始向下<strong>深度</strong>优先遍历。为遍历到的每个Fiber节点调用<code>beginWork方法</code>。👏 -- 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。</li><li>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</li></ul><h3 id="归-阶段-completework" tabindex="-1">“归”阶段 -- completeWork <a class="header-anchor" href="#归-阶段-completework" aria-label="Permalink to &quot;“归”阶段 -- completeWork&quot;">​</a></h3><ul><li>在“归”阶段会调用<code>completeWork</code>处理Fiber节点。👏</li><li>当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其<code>兄弟Fiber</code>的<code>递</code>阶段。</li><li>如果不存在兄弟Fiber，会进入<code>父级Fiber</code>的<code>归</code>阶段。</li><li><code>递</code>和<code>归</code>阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。</li></ul><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      i am</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">KaSong</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;"> /&gt;,</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">root</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span></code></pre></div><img src="`+l+`" width="60%/"><p>在<code>render</code>阶段会依次执行：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">1.</span><span style="color:#A6ACCD;"> rootFiber beginWork</span></span>
<span class="line"><span style="color:#F78C6C;">2.</span><span style="color:#A6ACCD;"> App Fiber beginWork</span></span>
<span class="line"><span style="color:#F78C6C;">3.</span><span style="color:#A6ACCD;"> div Fiber beginWork</span></span>
<span class="line"><span style="color:#F78C6C;">4.</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">i am</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> Fiber beginWork</span></span>
<span class="line"><span style="color:#F78C6C;">5.</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">i am</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> Fiber completeWork</span></span>
<span class="line"><span style="color:#F78C6C;">6.</span><span style="color:#A6ACCD;"> span Fiber beginWork</span></span>
<span class="line"><span style="color:#F78C6C;">7.</span><span style="color:#A6ACCD;"> span Fiber completeWork</span></span>
<span class="line"><span style="color:#F78C6C;">8.</span><span style="color:#A6ACCD;"> div Fiber completeWork</span></span>
<span class="line"><span style="color:#F78C6C;">9.</span><span style="color:#A6ACCD;"> App Fiber completeWork</span></span>
<span class="line"><span style="color:#F78C6C;">10.</span><span style="color:#A6ACCD;"> rootFiber completeWork</span></span></code></pre></div><h2 id="递-阶段-beginwork-1" tabindex="-1">“递”阶段 - beginWork <a class="header-anchor" href="#递-阶段-beginwork-1" aria-label="Permalink to &quot;“递”阶段 - beginWork&quot;">​</a></h2><p><a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075" target="_blank" rel="noreferrer">源码在此</a></p><p><code>beginWork</code>的工作是传入<code>当前Fiber</code>节点，根据<code>fiber.tag</code>来创建其<code>子Fiber</code>节点。并为Fiber节点带上<code>effectTag</code>属性。</p><p>beginWork的工作可以分为两部分：</p><ul><li><strong>update时</strong>：如果<code>current</code>存在，在<strong>满足一定条件时可以复用current节点</strong>，这样就能克隆current.child作为workInProgress.child，而不需要新建workInProgress.child。</li><li><strong>mount时</strong>：除<code>fiberRootNode</code>以外，current === null。会根据<code>fiber.tag（组件类型，类组件、函数组件...）</code>不同，进入不同类型Fiber的创建逻辑。根据不同的tag，来创建当前fiber节点的第一个<code>子Fiber节点</code>。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">beginWork</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">current</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">null</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">workInProgress</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 当前组件对应的Fiber节点</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">renderLanes</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Lanes</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 优先级相关</span></span>
<span class="line"><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">current</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 复用current</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">bailoutOnAlreadyFinishedWork</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">current</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">renderLanes</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">didReceiveUpdate</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// mount时：根据tag不同，创建不同的子Fiber节点</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">tag</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">IndeterminateComponent</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">LazyComponent</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">FunctionComponent</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ClassComponent</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">HostRoot</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">HostComponent</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">HostText</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...省略其他类型</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>对于我们常见的组件类型，如（FunctionComponent/ClassComponent/HostComponent），最终会进入<code>reconcileChildren</code>方法。</p><h3 id="reconcilechildren" tabindex="-1">reconcileChildren <a class="header-anchor" href="#reconcilechildren" aria-label="Permalink to &quot;reconcileChildren&quot;">​</a></h3><p>通过current === null 区分mount与update</p><ul><li>对于<strong>mount</strong>的组件，他会创建新的<code>子Fiber节点</code>。调用<code>mountChildFibers</code>方法</li><li>对于<strong>update</strong>的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就<strong>Diff</strong>算法❗ ，详见 <strong>《React核心原理2-diff》</strong>，将比较的结果生成新Fiber点。调用<code>reconcileChildFibers</code>方法，会为Fiber节点带上<code>effectTag</code>属性。</li></ul><p>不论走哪个逻辑，最终他会生成<code>新的子Fiber节点</code>并赋值给<code>workInProgress.child</code>，作为本<code>beginWork</code>返回值，并作为下次<code>performUnitOfWork</code>执行时<code>workInProgress</code>的传参。</p><h3 id="effecttag" tabindex="-1">effectTag <a class="header-anchor" href="#effecttag" aria-label="Permalink to &quot;effectTag&quot;">​</a></h3><p>它表示，Render阶段结束后，通知Render（渲染器）要执行的DOM操作类型。保存在<code>fiber.effectTag</code>上。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要插入到页面中</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Placement </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*                */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b00000000000010</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要更新</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Update </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*                   */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b00000000000100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要插入到页面中并更新</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> PlacementAndUpdate </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*       */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b00000000000110</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// DOM需要删除</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Deletion </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*                 */</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0b0000000000100</span></span>
<span class="line"><span style="color:#89DDFF;">...</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><code>beginWork</code>的工作是传入<code>当前Fiber</code>节点，根据<code>fiber.tag</code>来创建其<code>子Fiber</code>节点。并为Fiber节点带上<code>effectTag</code>属性。</p><img src="`+p+`"><h2 id="归-阶段-completework-1" tabindex="-1">&quot;归&quot;阶段 - completeWork <a class="header-anchor" href="#归-阶段-completework-1" aria-label="Permalink to &quot;&quot;归&quot;阶段 - completeWork&quot;">​</a></h2><p><code>completeWork</code>也是针对不同<code>fiber.tag(组件类型，类组件、函数组件...）</code>调用不同的处理逻辑。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">completeWork</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">current</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">null</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">workInProgress</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#A6ACCD;font-style:italic;">renderLanes</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Lanes</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fiber</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newProps</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">pendingProps</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">tag</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">IndeterminateComponent</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">LazyComponent</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">SimpleMemoComponent</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">FunctionComponent</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ForwardRef</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Fragment</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Mode</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Profiler</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ContextConsumer</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">MemoComponent</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ClassComponent</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">HostRoot</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">updateHostContainer</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">HostComponent</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...省略</span></span></code></pre></div><h3 id="hostcomponen如何处理" tabindex="-1">HostComponen如何处理 <a class="header-anchor" href="#hostcomponen如何处理" aria-label="Permalink to &quot;HostComponen如何处理&quot;">​</a></h3><p>我们重点关注页面渲染所必须的<code>HostComponent</code>（即原生DOM组件对应的Fiber节点）</p><p>和<code>beginWork</code>一样，根据<code>current === null ?</code>判断是<code>mount</code>还是<code>update</code>。</p><ul><li><p><code>update</code>时：Fiber节点已经存在对应<code>DOM节点</code>，所以不需要生成DOM节点。主要工作是<code>updateHostComponent</code>调用处理<code>props</code>，比如：</p><ul><li>onClick、onChange等回调函数的注册</li><li>处理style prop</li><li>处理DANGEROUSLY_SET_INNER_HTML prop</li><li>处理children prop</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (current </span><span style="color:#89DDFF;">!==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> workInProgress</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">stateNode </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// update的情况</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">updateHostComponent</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">current</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">workInProgress</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">type</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">newProps</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">rootContainerInstance</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>在<code>updateHostComponent</code>内部，被处理完的props会被赋值给<code>workInProgress.updateQueue</code>，并最终会在<code>commit阶段</code>被渲染在页面上。</p></li><li><p><code>mount</code>时：主要有以下三个逻辑</p><ul><li>为Fiber节点生成对应的<code>DOM节点</code></li><li>将子孙DOM节点插入刚生成的DOM节点中</li><li>与update逻辑中的<code>updateHostComponent</code>类似的处理props的过程</li></ul></li></ul><h3 id="effectlist" tabindex="-1"><code>effectList</code> <a class="header-anchor" href="#effectlist" aria-label="Permalink to &quot;\`effectList\`&quot;">​</a></h3><blockquote><p><code>effectTag</code>表示<code>Fiber</code>节点在<code>commit阶段</code>要执行的<strong>Dom操作</strong>。</p></blockquote><p>作为DOM操作的依据，commit阶段需要找到所有有effectTag的Fiber节点并依次执行effectTag对应操作。难道需要在commit阶段再<strong>遍历</strong>一次Fiber树寻找effectTag !== null的Fiber节点么？</p><p>这显然是很低效的。</p><p>为了<strong>高效</strong>的找到有effectTag的节点，在completeWork的上层函数<code>completeUnitOfWork</code>中，每个执行完completeWork且存在<code>effectTag</code>的Fiber节点会被保存在一条被称为<code>effectList</code>的<strong>单向链表</strong>中。最终形成一条以rootFiber.firstEffect为起点的单向链表。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">nextEffect         nextEffect</span></span>
<span class="line"><span style="color:#A6ACCD;">rootFiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">firstEffect </span><span style="color:#89DDFF;">-----------&gt;</span><span style="color:#A6ACCD;"> fiber </span><span style="color:#89DDFF;">-----------&gt;</span><span style="color:#A6ACCD;"> fiber</span></span></code></pre></div><p>这样，在<code>commit阶段</code>只需要遍历<code>effectList</code>就能执行所有<code>effect</code>了。</p><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>completeWork的目的就是为了<code>创建对应的dom节点</code>插入对应的<code>父级节点</code>的dom节点, 为其添加<code>副作用</code>标识。</p><img src="`+t+`"><h1 id="commit阶段" tabindex="-1">commit阶段 <a class="header-anchor" href="#commit阶段" aria-label="Permalink to &quot;commit阶段&quot;">​</a></h1><p>在<code>rootFiber.firstEffect</code>上保存了一条<code>需要执行副作用</code>的Fiber节点的单向链表effectList，这些Fiber节点的<code>updateQueue</code>中保存了变化的props。</p><p>一些<code>副作用</code>对应的DOM操作、一些生命周期钩子（componentDidXXX）、某些hook（useEffect）都在commit阶段执行</p><p>commit阶段的主要工作（即Renderer的工作流程）分为三部分：</p><ul><li><code>before mutation</code>阶段（执行DOM操作前）</li><li><code>mutation</code>阶段（执行DOM操作）</li><li><code>layout</code>阶段（执行DOM操作后）</li></ul><p>另外，</p><ul><li>在before mutation之前：主要做一些变量赋值，状态重置的工作。</li><li>在layout阶段之后： <ol><li>useEffect相关处理</li><li>性能追踪相关</li><li>执行同步任务, 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行, useLayoutEffect、useEffect的回调方法也会在这里被执行</li></ol></li></ul><h2 id="before-mutation阶段-执行dom操作前" tabindex="-1">before mutation阶段（执行DOM操作前） <a class="header-anchor" href="#before-mutation阶段-执行dom操作前" aria-label="Permalink to &quot;before mutation阶段（执行DOM操作前）&quot;">​</a></h2><p>在before mutation阶段，会遍历<code>effectList</code>（保存effectTag的单向链表），并调用<code>commitBeforeMutationEffects</code>函数，依次执行：</p><ol><li>处理DOM节点渲染/删除后的 autoFocus、blur逻辑</li><li>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子 <blockquote><p>从Reactv16开始，<code>componentWillXXX</code>钩子前增加了<code>UNSAFE_</code>前缀。但提供了替代的生命周期钩子 <code>getSnapshotBeforeUpdate</code>。</p></blockquote></li><li>调度<code>useEffect</code><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 调度useEffect</span></span>
<span class="line"><span style="color:#A6ACCD;">if ((effectTag &amp; Passive) !== NoEffect) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  if (!rootDoesHavePassiveEffects) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    rootDoesHavePassiveEffects = true;</span></span>
<span class="line"><span style="color:#A6ACCD;">    scheduleCallback(NormalSchedulerPriority, () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">      // 触发useEffect</span></span>
<span class="line"><span style="color:#A6ACCD;">      flushPassiveEffects();</span></span>
<span class="line"><span style="color:#A6ACCD;">      return null;</span></span>
<span class="line"><span style="color:#A6ACCD;">    });</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><code>scheduleCallback</code>方法由<code>Scheduler</code>模块提供，用于以某个<strong>优先级异步调度一个回调函数</strong>。异步调度主要是防止同步执行时阻塞浏览器渲染。</li></ol><h2 id="mutation阶段-执行dom操作" tabindex="-1">mutation阶段（执行DOM操作） <a class="header-anchor" href="#mutation阶段-执行dom操作" aria-label="Permalink to &quot;mutation阶段（执行DOM操作）&quot;">​</a></h2><p>mutation阶段会遍历 <code>effectList</code>，依次执行<code>commitMutationEffects</code>。该方法的主要工作为根据<code>effectTag</code>调用不同的处理函数<code>处理Fiber</code>，执行DOM操作。</p><p>对每个<code>Fiber</code>节点执行如下三个操作：</p><ul><li>根据<code>ContentReset effectTag</code>重置文字节点</li><li>更新<code>ref</code></li><li>根据<code>effectTag</code>分别处理，其中effectTag包括(<code>Placement</code> | <code>Update</code> | <code>Deletion</code> | <code>Hydrating</code>等)</li></ul><h3 id="placement-effect" tabindex="-1">Placement effect <a class="header-anchor" href="#placement-effect" aria-label="Permalink to &quot;Placement effect&quot;">​</a></h3><p>含有<code>Placement effectTag</code>，意味着该Fiber节点对应的DOM节点需要<strong>插入</strong>到页面中。调用的方法为<code>commitPlacement</code>。</p><p>该方法所做的工作分为三步：</p><ol><li><p>获取父级DOM节点。其中finishedWork为传入的Fiber节点。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> parentFiber </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getHostParentFiber</span><span style="color:#A6ACCD;">(finishedWork)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 父级DOM节点</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> parentStateNode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> parentFiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">stateNode</span><span style="color:#89DDFF;">;</span></span></code></pre></div></li><li><p>获取Fiber节点的DOM兄弟节点</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> before </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getHostSibling</span><span style="color:#A6ACCD;">(finishedWork)</span><span style="color:#89DDFF;">;</span></span></code></pre></div></li><li><p>根据DOM兄弟节点是否存在决定调用<code>parentNode.insertBefore</code>或<code>parentNode.appendChild</code>执行DOM插入操作。</p></li></ol><h3 id="update-effect" tabindex="-1">Update effect <a class="header-anchor" href="#update-effect" aria-label="Permalink to &quot;Update effect&quot;">​</a></h3><p>含有<code>Update effectTag</code>，意味着该Fiber节点需要<strong>更新</strong>。调用的方法为<code>commitWork</code>，他会根据Fiber.tag分别处理。</p><h3 id="deletion-effect" tabindex="-1">Deletion effect <a class="header-anchor" href="#deletion-effect" aria-label="Permalink to &quot;Deletion effect&quot;">​</a></h3><p>含有<code>Deletion effectTag</code>，意味着该Fiber节点对应的DOM节点需要从页面中<strong>删除</strong>。调用的方法为<code>commitDeletion</code>。</p><p>该方法会执行如下操作：</p><ol><li>递归调用<code>Fiber节点</code>及其子孙Fiber节点中fiber.tag为<code>ClassComponent</code>的<code>componentWillUnmount</code>生命周期钩子，从页面<strong>移除</strong>Fiber节点对应DOM节点</li><li>解绑ref</li><li>调度<code>useEffect</code>的销毁函数</li></ol><h2 id="layout阶段-执行dom操作后" tabindex="-1">layout阶段（执行DOM操作后） <a class="header-anchor" href="#layout阶段-执行dom操作后" aria-label="Permalink to &quot;layout阶段（执行DOM操作后）&quot;">​</a></h2><p>layout阶段也会遍历 <code>effectList</code>，依次执行<code>commitLayoutEffects</code>。该方法的主要工作为根据<code>effectTag</code>调用不同的处理函数<code>处理Fiber</code>并更新<code>ref</code>。</p><p><code>commitLayoutEffects</code>一共做了两件事：</p><ol><li><code>commitLayoutEffectOnFiber</code>（调用生命周期钩子和hook相关操作） <ul><li><p>对于<code>ClassComponent</code>，他会通过<code>current === null?</code>区分是<code>mount</code>还是<code>update</code>，调用<code>componentDidMount</code>或<code>componentDidUpdate</code>。 触发状态更新的<code>this.setState</code>如果赋值了<strong>第二个参数回调函数</strong>，也会在此时调用。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">setState</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">xxx</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">i am update~</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div></li><li><p>对于<code>FunctionComponent</code>及<code>相关类型</code>，他会调用<code>useLayoutEffect hook</code>的回调函数，调度<code>useEffect</code>的销毁与回调函数</p><blockquote><p><code>相关类型</code>指特殊处理后的FunctionComponent，比如ForwardRef、React.memo包裹的FunctionComponent</p></blockquote></li></ul></li><li><code>commitAttachRef</code>（赋值 ref）: <strong>获取DOM实例，更新ref</strong></li></ol><p>另外，在<code>layout</code>阶段，<strong>workInProgress Fiber树在commit阶段完成渲染后会变为current Fiber树</strong>。</p>`,89),i=[r];function y(F,D,d,C,f,A){return n(),a("div",null,i)}const b=s(c,[["render",y]]);export{u as __pageData,b as default};
