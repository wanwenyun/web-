import{_ as e,o,c as a,V as t}from"./chunks/framework.75331a37.js";const y=JSON.parse('{"title":"前言","description":"","frontmatter":{},"headers":[],"relativePath":"其他/单页面应用路由-hash、history模式.md","filePath":"其他/单页面应用路由-hash、history模式.md"}'),h={name:"其他/单页面应用路由-hash、history模式.md"},r=t('<ul><li><a href="#前言">前言</a></li><li><a href="#hash模式">Hash模式</a><ul><li><a href="#react-路由hash模式实现原理">react 路由hash模式实现原理</a></li></ul></li><li><a href="#history模式">history模式</a><ul><li><a href="#react-路由history模式实现原理">react 路由history模式实现原理</a></li></ul></li></ul><h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h1><p>前端路由是指在单页面应用（SPA）中，<strong>通过改变 URL 路径来实现页面的切换和状态的管理的一种技术</strong>。相比传统的多页面应用，前端路由可以提高用户的体验，避免了多次请求页面资源的时间消耗，并且可以实现更好的管理和控制页面状态。</p><p>简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。 为实现这一目标，我们需要做到以下二点：</p><ul><li>改变 url 且不让浏览器像服务器发送请求。</li><li>可以监听到 url 的变化</li></ul><p>通常在前端路由中，可以通过使用一些开源库来实现，比如 React Router、Vue Router 等，它们都提供了统一而易于使用的 API 来根据 URL 路径进行视图的切换和状态的管理。</p><p>前端路由的实现主要有两种方式：<code>hash</code> 模式和 <code>history</code> 模式。 hash 模式是通过 URL 的哈希值来实现路由的跳转，比如 <code>http://domain.com/#/path；history</code> 模式是通过 HTML5 中的 history API 来实现路由的切换，比如 <code>http://domain.com/path</code>。</p><p>无论是哪种方式，前端路由的实现都要依赖于 <strong>JavaScript 和浏览器</strong>的特性，因此需要考虑浏览器兼容性和页面加载速度等问题。</p><h1 id="hash模式" tabindex="-1">Hash模式 <a class="header-anchor" href="#hash模式" aria-label="Permalink to &quot;Hash模式&quot;">​</a></h1><p><code>hash</code> 就是指 url 后的 <code>#</code> 号以及后面的字符。比如说 &quot;www.baidu.com/#hashhash&quot; ，其中 &quot;#hashhash&quot; 就是我们期望的 <code>hash</code> 值。</p><p><strong>由于 hash 值的变化不会导致浏览器像服务器发送请求</strong>，而且 hash 的改变会触发 <code>hashchange</code> 事件，浏览器的前进后退也能对其进行控制，所以在 H5 的 history 模式出现之前，基本都是使用 hash 模式来实现前端路由。</p><p>使用 Hash 模式的好处是，<strong>可以避免因为路由变化而导致整个页面的刷新</strong>，因为 hash 只会影响到 URL 的一部分，不会触发完整的页面重新加载。这也是单页面应用中常用的一种路由模式。</p><h2 id="react-路由hash模式实现原理" tabindex="-1">react 路由hash模式实现原理 <a class="header-anchor" href="#react-路由hash模式实现原理" aria-label="Permalink to &quot;react 路由hash模式实现原理&quot;">​</a></h2><p>React 路由的 Hash 模式指的是 URL 地址中以 # 开头的部分用于匹配路由，而不是直接将地址路径作为路由匹配。</p><p>实现 Hash 模式的原理是：</p><ol><li><p>首先在页面中引入 <code>React Router</code> 库，并在路由配置中设置 <code>HashRouter</code> 作为根组件。</p></li><li><p>在 HashRouter 组件中包含一组 Route 组件，并为每个 Route 组件指定对应的路径和组件。</p></li><li><p>当用户在浏览器地址栏中输入或点击链接访问某个路由时，浏览器会自动将 # 后面的部分作为路由路径，然后通过 React 路由匹配器找到对应的组件进行渲染。</p></li><li><p>用户在页面中点击链接跳转到新的路由时，需要在链接中指定跳转的路径，同时使用 <code>window.location.hash</code> 改变 URL 中的 hash 值，从而触发路由匹配器对新路由进行渲染。</p></li></ol><p>需要注意的是，由于 Hash 模式使用的是 URL 中的 hash 值，所以即使通过链接或页面跳转到新的路由，也不会向服务器发送请求，而只是在客户端进行页面切换。</p><h1 id="history模式" tabindex="-1">history模式 <a class="header-anchor" href="#history模式" aria-label="Permalink to &quot;history模式&quot;">​</a></h1><p>这种模式充分利用了<code>html5 history interface</code> 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法。这两个方法应用于浏览器记录栈，在当前已有的 <code>back、forward、go</code>基础之上，它们提供了对历史记录修改的功能。这些方法通常与<code>window.onpopstate</code> 配合使用。只是当它们执行修改时，虽然改变了当前的 URL ，但<strong>浏览器不会立即向后端发送请求</strong>。</p><p>history.pushState() 和 history.replaceState() 的区别在于：</p><ul><li><code>history.pushState()</code> 在保留现有历史记录的同时，将 url 加入到历史记录中。</li><li><code>history.replaceState()</code> 会将历史记录中的当前页面历史替换为 url。</li></ul><p>通过监听 <code>popstate</code>事件，获取URL的变化。</p><h2 id="react-路由history模式实现原理" tabindex="-1">react 路由history模式实现原理 <a class="header-anchor" href="#react-路由history模式实现原理" aria-label="Permalink to &quot;react 路由history模式实现原理&quot;">​</a></h2><p>React Router 的 history 模式是通过 HTML5 的 History API 实现的。在 history 模式下，页面的路由使用 URL 路径名来表示，而不是使用 URL 中的 hash 部分。</p><p>具体实现原理如下：</p><p>1.首先，通过 <code>window.addEventListener(&#39;popstate&#39;, callback)</code> 监听 URL 的变化。当浏览器的前进或后退按钮被点击时，会触发 <code>popstate</code> 事件，callback 函数就会被调用。</p><p>2.使用 <code>pushState</code> 和 <code>replaceState</code> 方法，通过 JavaScript 来改变历史记录。<code>pushState</code> 方法可以向浏览器历史记录栈中添加一个新的状态记录，而 <code>replaceState</code> 则可以替换栈顶的状态记录，都不会触发页面的刷新。</p><p>3.在初始化时，需要调用 <code>createBrowserHistory</code> 创建一个 <code>history</code> 对象，它是整个路由系统的核心，负责管理浏览器历史记录、触发导航事件等。</p><p>4.接下来需要将 <code>history</code> 对象传递给 <code>&lt;Router&gt;</code> 组件，以便让 React Router 监听到 <code>history</code> 对象上的变化，并自动更新组件状态。</p><p>总结一下，history 模式的实现原理是通过监听 popstate 事件和使用 History API 来实现的，然后再将 <code>history</code> 对象传递给 React Router 组件，以便进行状态管理和导航。</p>',30),c=[r];function s(i,d,p,l,n,u){return o(),a("div",null,c)}const R=e(h,[["render",s]]);export{y as __pageData,R as default};
