import{_ as o,o as e,c as s,V as a}from"./chunks/framework.75331a37.js";const l="/assets/pic1.d44ea1b8.png",n="/assets/keep-login.a93251b9.png",t="/assets/pic2.e4887888.png",D=JSON.parse('{"title":"Cookie，document.cookie","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/存储-cookie、localStorage、sessionStorage、登陆保持.md","filePath":"浏览器/存储-cookie、localStorage、sessionStorage、登陆保持.md"}'),i={name:"浏览器/存储-cookie、localStorage、sessionStorage、登陆保持.md"},c=a(`<ul><li><a href="#cookiedocumentcookie">Cookie，document.cookie</a><ul><li><a href="#cookie的参数">Cookie的参数</a></li><li><a href="#cookie函数">Cookie函数</a></li><li><a href="#登录状态是如何保持的">登录状态是如何保持的？</a></li></ul></li><li><a href="#web-存储对象localstoragesessionstorage">Web 存储对象：LocalStorage，sessionStorage</a><ul><li><a href="#storage事件">Storage事件</a></li></ul></li><li><a href="#indexeddb">IndexedDB</a></li><li><a href="#总结cookielocalstoragesessionstorageindexdb">总结cookie，localStorage，sessionStorage，indexDB</a></li><li><a href="#cookiesessiontoken的区别">Cookie、Session、token的区别</a><ul><li><a href="#session">session</a></li><li><a href="#cookie">cookie</a></li><li><a href="#token">token</a></li></ul></li></ul><p><a href="https://zh.javascript.info/data-storage" target="_blank" rel="noreferrer">参考链接</a></p><h1 id="cookie-document-cookie" tabindex="-1">Cookie，document.cookie <a class="header-anchor" href="#cookie-document-cookie" aria-label="Permalink to &quot;Cookie，document.cookie&quot;">​</a></h1><p>Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分，由 <a href="https://www.rfc-editor.org/rfc/rfc6265" target="_blank" rel="noreferrer">RFC 6265</a> 规范定义。</p><p>Cookie 通常是由 Web 服务器使用响应 <code>Set-Cookie</code> HTTP-header 设置的。然后浏览器使用 Cookie HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中。</p><p>Cookie的常见用处之一是身份验证：</p><ol><li>登录后，服务器在响应中使用 <code>Set-Cookie</code> HTTP-header 来设置具有唯一“会话标识符（session identifier）”的 cookie。</li><li>下次当请求被发送到同一个域时，浏览器会使用 Cookie HTTP-header 通过网络发送 <code>cookie</code>。</li><li>所以服务器知道是谁发起了请求。</li></ol><p>可以用 <code>document.cookie</code> 属性从浏览器访问 cookie。</p><p>限制：</p><ol><li>Cookie大小限制为<code>4K</code></li><li>每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">document.cookie = &quot;username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/&quot;    // 设置cookie</span></span>
<span class="line"><span style="color:#A6ACCD;">document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;    // 删除cookie</span></span></code></pre></div><h2 id="cookie的参数" tabindex="-1">Cookie的参数 <a class="header-anchor" href="#cookie的参数" aria-label="Permalink to &quot;Cookie的参数&quot;">​</a></h2><img src="`+l+`"><ul><li><p><code>path</code>：表示该路径下的页面可以访问该 cookie</p><p>如果一个 cookie 带有 path=/admin 设置，那么该 cookie 在 <code>/admin 和 /admin/something</code> 下都是可见的，但是在 /home 或 其他 下不可见。</p><p>通常，我们应该将 path 设置为根目录：<code>path=/</code>，以使 cookie 对此网站的所有页面可见。</p></li><li><p><code>domain</code>：控制了可访问 cookie 的域。</p><p>比如：<code>document.cookie = &quot;name=value;domain=.baidu.com&quot;</code>，所有*.baidu.com的主机都可以访问该cookie。</p></li><li><p><code>expires，max-age</code>：为了让 cookie 在<strong>浏览器关闭</strong>后仍然存在，我们可以设置 expires 或 max-age 选项中的一个。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">expires=Tue, 19 Jan 2038 03:14:07 GMT</span></span>
<span class="line"><span style="color:#A6ACCD;">max-age=3600</span></span></code></pre></div></li></ul><ul><li><code>secure</code>：表示Cookie 应只能被通过 HTTPS 传输。</li></ul><ul><li><p><code>samesite</code>：选项通常有 <code>Strict</code>、<code>Lax</code> 和 <code>None</code> 三个值。</p><ul><li><p>Strict：那么浏览器会完全禁止第三方 Cookie。</p></li><li><p>Lax：从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</p></li><li><p>None：在任何情况下都会发送 Cookie 数据。</p><p>它旨在防止 <code>CSRF</code>（跨网站请求伪造）攻击。</p></li></ul></li><li><p><code>httpOnly</code>：这个选项禁止任何 JavaScript 访问 cookie。我们使用 document.cookie 看不到此类 cookie，也无法对此类 cookie 进行操作。</p><p>设置了httpOnly, 如果用户访问了带有黑客 JavaScript 代码的页面，黑客代码将执行但无法通过 document.cookie 获取到包含用户身份验证信息的 cookie。所以攻击会被预防。</p><p>可以用于防范<code>XSS</code>攻击。</p></li></ul><h2 id="cookie函数" tabindex="-1">Cookie函数 <a class="header-anchor" href="#cookie函数" aria-label="Permalink to &quot;Cookie函数&quot;">​</a></h2><ul><li>getCookie(name)</li></ul><ul><li>setCookie(name, value, options)</li><li>deleteCookie(name)</li></ul><h2 id="登录状态是如何保持的" tabindex="-1">登录状态是如何保持的？ <a class="header-anchor" href="#登录状态是如何保持的" aria-label="Permalink to &quot;登录状态是如何保持的？&quot;">​</a></h2><ul><li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 <strong>POST</strong> 方法提交用户登录信息给服务器。</li></ul><ul><li><p>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 <code>Set-Cookie</code> 字段里，如下所示，然后把响应头发送给浏览器。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Set-Cookie: UID=3431uad;</span></span></code></pre></div></li></ul><ul><li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息<strong>保存到本地</strong>。比如把UID=3431uad保持到本地。</li></ul><ul><li><p>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 <code>Cookie</code> 数据，并自动把数据写进<strong>请求头</strong>里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Cookie: UID=3431uad;</span></span></code></pre></div></li></ul><ul><li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的<code>Cookie</code>字段信息，当查找到包含<code>UID=3431uad</code>的信息时，服务器查询后台，并判断该用户是<strong>已登录状态</strong>，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li></ul><ul><li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。</li></ul><img src="`+n+`" width="50%/"><p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容<strong>保持到本地</strong>。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p><h1 id="web-存储对象-localstorage-sessionstorage" tabindex="-1">Web 存储对象：LocalStorage，sessionStorage <a class="header-anchor" href="#web-存储对象-localstorage-sessionstorage" aria-label="Permalink to &quot;Web 存储对象：LocalStorage，sessionStorage&quot;">​</a></h1><p>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。</p><p>我们已经有了 cookie。为什么还要其他存储对象呢？</p><ul><li>与 cookie 不同，<strong>Web 存储对象不会随每个请求被发送到服务器</strong>。因此，我们可以保存更多数据。大多数现代浏览器都允许保存至少 <code>5MB</code> 的数据（或更多），并且具有用于配置数据的设置。 还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是* 在 <code>JavaScript</code> 中完成的。</li><li>key 和 value 都必须为<code>字符串</code>。</li><li>存储绑定到源（<code>域/协议/端口三者</code>）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。</li></ul><p>两个存储对象都提供相同的方法和属性：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">setItem(key, value) —— 存储键/值对。</span></span>
<span class="line"><span style="color:#A6ACCD;">getItem(key) —— 按照键获取值。</span></span>
<span class="line"><span style="color:#A6ACCD;">removeItem(key) —— 删除键及其对应的值。</span></span>
<span class="line"><span style="color:#A6ACCD;">clear() —— 删除所有数据。</span></span>
<span class="line"><span style="color:#A6ACCD;">key(index) —— 获取该索引下的键名。</span></span>
<span class="line"><span style="color:#A6ACCD;">length —— 存储的内容的长度。</span></span></code></pre></div><table><thead><tr><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>在<strong>同源</strong>的所有标签页和窗口之间共享数据。</td><td>在当前浏览器标签页中可见，包括同源的 iframe（同一标签页下的 iframe 之间是共享）。</td></tr><tr><td>浏览器重启后数据仍然保留</td><td>页面刷新后数据仍然保留（但标签页关闭后数据则不再保留）</td></tr></tbody></table><h2 id="storage事件" tabindex="-1">Storage事件 <a class="header-anchor" href="#storage事件" aria-label="Permalink to &quot;Storage事件&quot;">​</a></h2><p>当 localStorage 或 sessionStorage 中的数据更新(例如：setItem，removeItem，clear 方法)后，storage 事件就会触发，它具有以下属性：</p><ul><li>key —— 发生更改的数据的 key（如果调用的是 .clear() 方法，则为 null）。</li><li>oldValue —— 旧值（如果是新增数据，则为 null）。</li><li>newValue —— 新值（如果是删除数据，则为 null）。</li><li>url —— 发生数据更新的文档的 url。</li><li>storageArea —— 发生数据更新的 localStorage 或 sessionStorage 对象。</li></ul><p>该事件会在所有可访问到存储对象的 window 对象上触发</p><p>假设有两个窗口，它们具有相同的页面。所以 localStorage 在它们之间是共享的。</p><p>如果两个窗口都在监听 window.onstorage 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 在其他文档对同一存储进行更新时触发</span></span>
<span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onstorage</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">event</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 也可以使用 window.addEventListener(&#39;storage&#39;, event =&gt; {</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">now</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">alert</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">newValue</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> at </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">url</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setItem</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">now</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Date</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">now</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h1 id="indexeddb" tabindex="-1">IndexedDB <a class="header-anchor" href="#indexeddb" aria-label="Permalink to &quot;IndexedDB&quot;">​</a></h1><p>IndexedDB 是一个浏览器内建的数据库，它比 localStorage 强大得多。</p><ul><li>通过支持多种类型的键，来存储几乎可以是任何类型的值。</li><li>支撑事务的可靠性。</li><li>支持键值范围查询、索引。</li><li>和 localStorage 相比，它可以存储更大的数据量。</li></ul><p>IndexedDB 适用于离线应用，可与 ServiceWorkers 和其他技术相结合使用。</p><h1 id="总结cookie-localstorage-sessionstorage-indexdb" tabindex="-1">总结cookie，localStorage，sessionStorage，indexDB <a class="header-anchor" href="#总结cookie-localstorage-sessionstorage-indexdb" aria-label="Permalink to &quot;总结cookie，localStorage，sessionStorage，indexDB&quot;">​</a></h1><img src="`+t+'"><h1 id="cookie、session、token的区别" tabindex="-1">Cookie、Session、token的区别 <a class="header-anchor" href="#cookie、session、token的区别" aria-label="Permalink to &quot;Cookie、Session、token的区别&quot;">​</a></h1><h2 id="session" tabindex="-1">session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;session&quot;">​</a></h2><p>session的中文翻译是“会话”，当用户打开某个web应用时，便与web服务器产生一次session。服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。</p><h2 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h2><p>cookie是保存在本地终端的数据。在后端设置,保存在客户端本地文件,通过set-cookie设置且Cookie的内容自动在请求的时候被传递到服务器。大小不超过<code>4KB</code>，它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。域的cookie数量是有限的。</p><h2 id="token" tabindex="-1">token <a class="header-anchor" href="#token" aria-label="Permalink to &quot;token&quot;">​</a></h2><p>token的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库</p>',55),p=[c];function r(d,k,u,h,C,g){return e(),s("div",null,p)}const F=o(i,[["render",r]]);export{D as __pageData,F as default};
