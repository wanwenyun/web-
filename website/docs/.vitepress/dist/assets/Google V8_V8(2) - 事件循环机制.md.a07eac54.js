import{_ as s,o as n,c as a,V as o}from"./chunks/framework.75331a37.js";const l="/assets/code5.e8cd6d41.png",p="/assets/pic6.97e2e6f7.png",e="/assets/micro.2a332dfa.png",t="/assets/EventLoop1.d8f0a2ff.png",c="/assets/EventLoop2.7cf60233.png",r="/assets/EventLoop3.071c4bbc.png",y="/assets/EventLoop4.69edd702.png",F="/assets/EventLoop5.f26e574a.png",i="/assets/EventLoop6.ff43d40c.png",v=JSON.parse('{"title":"V8怎么实现回调函数的？","description":"","frontmatter":{},"headers":[],"relativePath":"Google V8/V8(2) - 事件循环机制.md","filePath":"Google V8/V8(2) - 事件循环机制.md"}'),D={name:"Google V8/V8(2) - 事件循环机制.md"},A=o('<ul><li><a href="#v8怎么实现回调函数的">V8怎么实现回调函数的？</a></li><li><a href="#事件循环机制">事件循环机制</a><ul><li><a href="#宏任务网络请求文件读写settimeoutsetinterval">宏任务(网络请求、文件读写、setTimeout/setInterval)</a></li><li><a href="#微任务promisethen或rejectawait下一条语句">微任务（Promise.then(或.reject)、await下一条语句）</a></li><li><a href="#nexttick">nextTick</a></li><li><a href="#宏任务和微任务的执行过程">宏任务和微任务的执行过程</a></li><li><a href="#eventloop---过程详解">EventLoop - 过程详解</a></li><li><a href="#面试问题">面试问题</a></li></ul></li><li><a href="#异步编程发展史">异步编程发展史</a></li><li><a href="#结合promise和asyncawait的事件循环例题">结合Promise和async/await的事件循环例题</a></li></ul><h1 id="v8怎么实现回调函数的" tabindex="-1">V8怎么实现回调函数的？ <a class="header-anchor" href="#v8怎么实现回调函数的" aria-label="Permalink to &quot;V8怎么实现回调函数的？&quot;">​</a></h1><blockquote><p>参考链接：<a href="https://time.geekbang.org/column/article/227926" target="_blank" rel="noreferrer">https://time.geekbang.org/column/article/227926</a> 回调函数有两种类型：同步回调和异步回调</p></blockquote><ol><li><strong>同步</strong>回调函数是在执行函数内部被执行的</li><li><strong>异步</strong>回调函数是在执行函数外部被执行的。同时异步回调也有两种不同的类型，其典型代表是 <code>setTimeout</code> 和 <code>XMLHttpRequest</code>。 <ul><li>在 setTimeout 函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数。</li><li>网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加进消息队列中，然后主线程从消息队列中取出回调事件，并执行回调函数。</li></ul></li></ol><h1 id="事件循环机制" tabindex="-1">事件循环机制 <a class="header-anchor" href="#事件循环机制" aria-label="Permalink to &quot;事件循环机制&quot;">​</a></h1><blockquote><p>参考链接：<a href="https://time.geekbang.org/column/article/229532" target="_blank" rel="noreferrer">https://time.geekbang.org/column/article/229532</a> 普通的UI线程架构：每个 UI 线程都拥有一个消息队列，所有的待执行的事件都会被添加进消息队列中，UI 线程会按照一定规则，循环地取出消息队列中的事件，并执行事件。</p></blockquote><p>js在此基础上又延伸出很多新技术，比如<strong>宏任务，微任务</strong>。</p><h2 id="宏任务-网络请求、文件读写、settimeout-setinterval" tabindex="-1">宏任务(网络请求、文件读写、setTimeout/setInterval) <a class="header-anchor" href="#宏任务-网络请求、文件读写、settimeout-setinterval" aria-label="Permalink to &quot;宏任务(网络请求、文件读写、setTimeout/setInterval)&quot;">​</a></h2><p>宏任务：指消息队列中的<code>等待</code>被<strong>主线程</strong>执行的事件。常见的宏任务有：</p><ol><li>渲染事件</li><li>用户交互事件</li><li>js脚本执行</li><li>网络请求、文件读写完成事件</li><li>以及<code>setTimeout/setInterval</code>这样的定时器回调等等。</li></ol><p>PS：<strong>setTomeout的输出顺序，跟其等待的时间也有关系，等待时间越短，越早输出</strong></p><p>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种<code>队列</code>的方式来存储这些任务， 即<strong>先进来的先执行</strong>。</p><p>另外，队列又分为两种：<strong>普通任务队列</strong>和<strong>延迟队列</strong>。其中延迟队列是专门用来处理比如<code>setTimeout/setInterval</code>这样的定时器回调任务的。</p><table><thead><tr><th>代码</th><th>执行过程</th></tr></thead><tbody><tr><td><img src="'+l+'"></td><td><img src="'+p+'" width="65%/"></td></tr></tbody></table><blockquote><p>使用setTimeout可以将foo函数转化为<strong>宏任务</strong>放入延迟消息队列中，解决了<strong>栈溢出</strong>的问题</p></blockquote><p>上述提到的，普通任务队列和延迟队列中的任务，都属于<strong>宏任务</strong>。</p><h2 id="微任务-promise-then-或-reject-、await下一条语句" tabindex="-1">微任务（Promise.then(或.reject)、await下一条语句） <a class="header-anchor" href="#微任务-promise-then-或-reject-、await下一条语句" aria-label="Permalink to &quot;微任务（Promise.then(或.reject)、await下一条语句）&quot;">​</a></h2><p>引入微任务的初衷是为了解决异步回调的问题。</p><p>微任务：可以看成是一个需要<strong>异步</strong>执行的函数，执行时机是在主函数执行结束之<strong>后</strong>、<strong>当前</strong>宏任务结束之<strong>前</strong>。V8 会为每个宏任务维护一个微任务队列。</p><p>微任务带来了两个优势：</p><ul><li><strong>实时性</strong>：解决了宏任务的时间颗粒度太粗，导致<strong>应用卡顿</strong>的问题。宏任务无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡。</li><li>解决了浪费 CPU 性能的问题：可以改变我们现在的异步编程模型，使得我们可以使用<strong>同步形式</strong>的代码来编写异步调用。</li></ul><img src="'+e+`" width="60%/"><p>微任务是基于消息队列、事件循环、UI 主线程还有堆栈而来的，然后基于<strong>微任务</strong>，又可以延伸出<code>协程、Promise、Generator、await/async</code> 等现代前端经常使用的一些技术。</p><p>常见的<strong>微任务</strong>有</p><ol><li><code>MutationObserver</code>(提供了监视对 DOM 树所做更改的能力)、<code>Promise.then(或.reject)</code></li><li>以及以 Promise 为基础开发的其他技术(比如<code>fetch API</code>), 还包括 V8 的垃圾回收过程。</li><li><code>await</code><strong>后面</strong>的语句会<code>同步</code>执行（await后面的语句可以看成是一个<code>Promise</code>来执行）。当Promise对象的状态变成<code>resolve</code>后，才会执行await的下一句语句，并且<code>await下一句语句会被当成微任务</code>添加到当前任务队列的末尾异步执行。</li></ol><p>PS:</p><ol><li><code>new Promise(******)</code>，****** 这个位置的代码是 <code>同步执行</code>的。<code>Promise.then(****)</code>是<strong>微任务</strong>，会放入微任务队列。</li><li>等待await后面的操作执行完毕(即返回Promise<code>成功状态</code>)，才会执行下一句语句, 并且会被当成<strong>微任务</strong>放在当前微任务队列末尾。如果得到Promise的<code>reject</code>值，则报错并结束该函数的执行，await下一条语句不会执行。</li></ol><h2 id="nexttick" tabindex="-1">nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;nextTick&quot;">​</a></h2><p>process.nextTick 属于微任务，是在当前执行栈的尾部，会照成IO阻塞</p><p>当事件循环准备进入下一个阶段(去取宏任务)之前，会先检<code>·nextTick queue</code>中是否有任务，如果有，那么会先清空这个队列。</p><p>当所有当<code>同步任务</code>执行完毕之后就会执行<code>nextTick</code></p><h2 id="宏任务和微任务的执行过程" tabindex="-1">宏任务和微任务的执行过程 <a class="header-anchor" href="#宏任务和微任务的执行过程" aria-label="Permalink to &quot;宏任务和微任务的执行过程&quot;">​</a></h2><p>开始 -&gt; 取第一个宏任务队列里的任务执行(可以认为同步任务队列是第一个task queue) -&gt; 取微任务队列全部任务依次执行 -&gt; 取下一个宏任务队列里的任务执行 -&gt; 再次取出微任务队列全部任务执行 -&gt; … 这样循环往复</p><h2 id="eventloop-过程详解" tabindex="-1">EventLoop - 过程详解 <a class="header-anchor" href="#eventloop-过程详解" aria-label="Permalink to &quot;EventLoop - 过程详解&quot;">​</a></h2><p>总结：</p><ol><li>一开始整段脚本作为第一个<code>宏任务</code>执行，并将<strong>全局执行上下文</strong>压入调用栈。并在执行上下文中创建一个空的微任务队列。</li><li>执行过程中<code>同步代码</code>直接压入<code>调用栈</code>直接执行，<code>宏任务</code>进入宏任务队列(即消息队列)，<code>微任务</code>进入微任务队列</li><li>&quot;调用栈&quot;中的所有同步任务执行完毕，当前宏任务执行完出队，理解检查当前<code>微任务队列</code>，如果有则依次执行，直到微任务队列为空</li><li>执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空。</li></ol><p><strong>PS：</strong></p><ul><li>同一次事件循环中，微任务永远在宏任务之前执行。</li><li>微任务是在当前的任务快要执行结束之前执行的，宏任务是消息队列中的任务，主线程执行完一个宏任务之后，便会接着从消息队列中取出下一个宏任务并执行。</li></ul><p><strong>具体例子：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">micro-bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  ) </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">macro-bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">micro-foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  ) </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">macro-foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">bar</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">global</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">micro-global</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">) </span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">macro-global</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>打印结果：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#A6ACCD;">global</span></span>
<span class="line"><span style="color:#A6ACCD;">micro</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#A6ACCD;">micro</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#A6ACCD;">micro</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">global</span></span>
<span class="line"><span style="color:#A6ACCD;">macro</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#A6ACCD;">macro</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#A6ACCD;">macro</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">global</span></span></code></pre></div><p><strong>过程分析：</strong></p><ol><li><p>一开始整段脚本作为第一个<code>宏任务</code>执行，并将<strong>全局执行上下文</strong>压入调用栈。</p><img src="`+t+'" width="80%/"></li><li><p>执行 foo 函数的调用，V8 会先创建 foo 函数的执行上下文，并将其压入到栈中。先执行同步代码，打印<code>foo</code>。接着执行 <code>Promise.resolve</code>，这会触发一个 micro-foo <strong>微</strong>任务，V8 会将该微任务添加进微任务队列。然后执行 <code>setTimeout</code> 方法。该方法会触发了一个 macro-foo <strong>宏</strong>任务，V8 会将该宏任务添加进消息队列。</p><img src="'+c+'" width="80%/"></li><li><p>foo 函数调用了 bar 函数，那么 V8 需要再创建 bar 函数的执行上下文，并将其压入栈中。也是先执行同步代码，打印<code>bar</code>。接着执行 <code>Promise.resolve</code>，这会触发一个 micro-bar <strong>微</strong>任务，该微任务会被添加进微任务队列。然后执行 <code>setTimeout</code> 方法，这也会触发一个 macro-bar <strong>宏</strong>任务，宏任务同样也会被添加进消息队列</p><img src="'+r+'" width="80%/"></li><li><p>bar 函数执行结束并退出，bar 函数的执行上下文也会从栈中弹出，紧接着 foo 函数执行结束并退出，foo 函数的执行上下文也随之从栈中被弹出。紧接着就执行同步代码， <code>console.log(&#39;global&#39;)</code>。</p><img src="'+y+'" width="80%/"></li><li><p>紧接着就要执行<strong>全局环境</strong>中的代码 Promise.resolve 了，这会触发一个 micro-global 微任务，V8 会将该微任务添加进微任务队列。接着又执行 setTimeout 方法，该方法会触发了一个 macro-global 宏任务，V8 会将该宏任务添加进消息队列。</p><img src="'+F+'" width="80%/"></li><li><p>当全局执行上下文环境中的代码执行完毕后，V8 会检查<strong>微任务队列</strong>，如果微任务队列中存在微任务，那么 V8 会依次取出微任务，并按照顺行执行(<strong>先进先出</strong>)。micro-foo、micro-bar、micro-global。</p><img src="'+i+`" width="80%/"></li><li><p>等微任务队列中的所有<strong>微任务</strong>都执行完成之后，当前的宏任务也就执行结束了.接。来主线程会继续重复执行从<strong>消息队列</strong>中取出任务、执行任务的过程。于正常情况下，取出宏任务的顺序是按照<strong>先进先出</strong>的顺序，所有最后打印出来的顺序是：macro-foo、macro-bar、macro-global。</p></li></ol><h2 id="面试问题" tabindex="-1">面试问题 <a class="header-anchor" href="#面试问题" aria-label="Permalink to &quot;面试问题&quot;">​</a></h2><ol><li><p><strong>执行宏任务时，遇到了微任务会怎么样执行？</strong></p><p>执行宏任务时，遇到微任务，会将该微任务放进微任务队列的末尾，当当前宏任务执行完毕之后，再按顺序执行微任务队列里面的任务。</p></li><li><p><strong>执行宏任务，遇到了宏任务呢？执行微任务，遇到宏任务呢？</strong></p><p>这两种情况一样，都会将宏任务放进宏任务队列的末尾。</p><p>始终牢记，微任务优先级高于宏任务，每一个宏任务执行完之后，一定会先去检查微任务队列是否有任务，等微任务全部执行完之后，才会继续执行下一个宏任务。</p></li><li><p><strong>在微任务触发新的微任务，会怎么样？</strong></p><p>当执行微任务时遇到微任务，会将新遇到的微任务放在当前微任务的末尾，等微任务队列清空之后，再执行下一个宏任务。</p></li><li><p><strong>在微任务中循环地触发新的微任务呢？</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">foo</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span></span></code></pre></div><p>当前的宏任务无法退出，导致消息队列中其他的宏任务是无法被执行的，具体体现为页面<strong>卡死</strong>。但<strong>不会造成栈溢出错误</strong>，因为由于 V8 每次执行微任务时，都会退出当前foo函数的调用栈。</p></li></ol><h1 id="异步编程发展史" tabindex="-1">异步编程发展史 <a class="header-anchor" href="#异步编程发展史" aria-label="Permalink to &quot;异步编程发展史&quot;">​</a></h1><p>详见 JavaScript基础 -《异步编程(promise、generator、async,await)》章节</p><h1 id="结合promise和async-await的事件循环例题" tabindex="-1">结合Promise和async/await的事件循环例题 <a class="header-anchor" href="#结合promise和async-await的事件循环例题" aria-label="Permalink to &quot;结合Promise和async/await的事件循环例题&quot;">​</a></h1><p><strong>例题一：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">3</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;">20</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">reject</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">run</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">5</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">6</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">run</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//需要执行150ms左右，虽然第二个setTimeout已经到达时间，但不会执行，</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F78C6C;">90000000</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">7</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">8</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">9</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>结果：<code>1 5 3 10 7 8 9 4 2</code></p><p>解释：</p><ol><li>首先执行同步代码，输出 1，遇见第一个setTimeout，将其回调放入任务队列（宏任务）当中，</li><li>继续往下执行运行run(),打印出 5，</li><li>并往下执行，遇见 await fn()，将其放入任务队列（微任务）</li><li>await fn() 当前这一行代码执行时，</li><li>fn函数会立即执行的,打印出3，</li><li>遇见第二个setTimeout，将其回调放入任务队列（宏任务），</li><li>await fn() 下面的代码需要等待返回Promise<code>成功状态</code>才会执行，所以6是不会被打印的。</li><li>继续往下执行，遇到for循环同步代码，<code>需要等150ms,虽然第二个setTimeout已经到达时间，但不会执行</code>，</li><li>遇见第三个setTimeout，将其回调放入任务队列（宏任务），然后打印出10。 值得注意的是，这个定时器 推迟时间0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。</li><li>同步代码执行完毕，此时没有微任务，就去执行宏任务，</li><li>上面提到<strong>已经到点</strong>的setTimeout先执行，打印出<strong>7</strong></li><li>然后new Promise的时候会立即把executor函数执行(是<strong>同步</strong>操作)，打印出8</li><li>然后在执行resolve时，触发微任务，于是打印出9</li><li>当前宏任务执行完毕，再去消息队列里面去下一个<strong>已经到点</strong>的setTimeout宏任务，打印出4</li><li>最后执行第一个setTimeout的宏任务，打印出2</li></ol><p>ps：<code>setTomeout的输出顺序，跟其等待的时间也有关系，等待时间越短，越早输出</code></p><p><strong>例题二：</strong></p><p>把例题一中的<code>return Promise.reject()</code>改成<code>return Promise.resolve()</code>，输出结果是什么</p><p>结果：<code>1 5 3 10 6 7 8 9 4 2</code></p><p>解释：</p><p>当Promise对象的状态变成<code>resolve</code>后，才会执行await的下一句语句，并且<code>await下一句语句会被当成微任务</code>添加到<strong>当前</strong>任务队列的末尾异步执行。</p><p>其他顺序不变</p><p><strong>例题3：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    	</span><span style="color:#676E95;font-style:italic;">// t2</span></span>
<span class="line"><span style="color:#F07178;">    	</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">t</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">// t1</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">t</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>结果：<code>4-&gt;3-&gt;2-&gt;1</code></p><p>解释：</p><ol><li>script 任务先运行。首先遇到 Promise 实例，构造函数首先执行，所以首先输出了 4。此时 microtask 的任务有 t2 和 t1，且顺序为t2 -&gt; t1</li><li>script 任务继续运行，输出 3。至此，第一个宏任务执行完成。</li><li>执行所有的微任务，先后取出 t2 和 t1，分别输出 2 和 1</li><li>代码执行完毕</li></ol><p>*为什么 t2 会先执行呢？*理由如下：</p><p>Promise.resolve 方法允许调用时不带参数，直接返回一个resolved 状态的 Promise 对象。立即 resolved 的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时</p><p><strong>例题4：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">async1</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">async1 start</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">async2</span><span style="color:#F07178;">()  </span><span style="color:#676E95;font-style:italic;">// async2是同步 await 之后的任务也是微任务（async1 end）</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">async1 end</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">async2</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">async2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">script start</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">setTimeout0</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">setTimeout3</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">setImmediate</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">nextTick</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)) </span><span style="color:#676E95;font-style:italic;">// 当所有当同步任务执行完毕之后就会执行nextTick</span></span>
<span class="line"><span style="color:#82AAFF;">async1</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 这个虽然放在了resolve（）之后，但也是同步任务，会被立即执行</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise3</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">script end</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>结果：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">script start</span></span>
<span class="line"><span style="color:#A6ACCD;">async1 start</span></span>
<span class="line"><span style="color:#A6ACCD;">async2</span></span>
<span class="line"><span style="color:#A6ACCD;">promise1</span></span>
<span class="line"><span style="color:#A6ACCD;">promise2</span></span>
<span class="line"><span style="color:#A6ACCD;">script end</span></span>
<span class="line"><span style="color:#A6ACCD;">nextTick</span></span>
<span class="line"><span style="color:#A6ACCD;">async1 end</span></span>
<span class="line"><span style="color:#A6ACCD;">promise3</span></span>
<span class="line"><span style="color:#A6ACCD;">setTimeout0</span></span>
<span class="line"><span style="color:#A6ACCD;">setTimeout3</span></span>
<span class="line"><span style="color:#A6ACCD;">setImmediate</span></span></code></pre></div>`,72),C=[A];function g(d,m,u,h,f,b){return n(),a("div",null,C)}const _=s(D,[["render",g]]);export{v as __pageData,_ as default};
