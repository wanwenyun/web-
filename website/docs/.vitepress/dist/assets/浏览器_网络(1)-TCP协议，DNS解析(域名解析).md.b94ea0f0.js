import{_ as e,o,c as l,V as a}from"./chunks/framework.75331a37.js";const i="/assets/pic2.262accd2.png",c="/assets/tcp1.ecc82d4e.png",t="/assets/tcp2.a0395459.png",r="/assets/dns.4a78a458.png",T=JSON.parse('{"title":"计算机网络体系","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/网络(1)-TCP协议，DNS解析(域名解析).md","filePath":"浏览器/网络(1)-TCP协议，DNS解析(域名解析).md"}'),d={name:"浏览器/网络(1)-TCP协议，DNS解析(域名解析).md"},s=a('<ul><li><a href="#计算机网络体系">计算机网络体系</a></li><li><a href="#tcp协议">TCP协议</a><ul><li><a href="#三次握手">三次握手</a><ul><li><a href="#为什么要三次握手">为什么要三次握手？</a></li><li><a href="#三次握手过程中可以携带数据吗">三次握手过程中可以携带数据吗？</a></li><li><a href="#syn-洪泛攻击">SYN 洪泛攻击</a></li><li><a href="#如果第三次握手丢失了客户端服务端会如何处理">如果第三次握手丢失了，客户端服务端会如何处理</a></li></ul></li><li><a href="#四次挥手">四次挥手</a><ul><li><a href="#等待2msl的意义">等待2MSL的意义</a></li><li><a href="#为什么是4次挥手">为什么是4次挥手</a></li></ul></li></ul></li><li><a href="#dns解析域名解析">DNS解析，域名解析</a></li></ul><h1 id="计算机网络体系" tabindex="-1">计算机网络体系 <a class="header-anchor" href="#计算机网络体系" aria-label="Permalink to &quot;计算机网络体系&quot;">​</a></h1><p>计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层）。</p><img src="'+i+'"><h1 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-label="Permalink to &quot;TCP协议&quot;">​</a></h1><blockquote><p><a href="https://segmentfault.com/a/1190000039165592" target="_blank" rel="noreferrer">参考链接</a></p></blockquote><p>tcp协议是<strong>传输层</strong>协议。TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。</p><p><strong>三次握手，建立连接</strong>。</p><p><strong>四次挥手，关闭连接</strong>。</p><p>http/1.1默认使用长连接，Connection:keep-alive，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。</p><h2 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h2><p>三次握手，建立连接过程如下：</p><img src="'+c+'" width="70%/"><p>图中字符的含义：</p><ul><li>SYN：连接请求/接收 报文段</li><li>seq：发送的第一个字节的序号</li><li>ACK：确认报文段</li><li>ack：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p>过程如下：</p><ol><li><strong>第一次握手</strong>：客户端向服务端发送一个 <code>SYN</code> 报文（<code>SYN = 1</code>），并指明客户端的初始化序列号 <code>ISN(x)</code>，即图中的 <code>seq = x</code>，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。 <blockquote><p><code>SYN-SENT</code> ：在发送连接请求后等待匹配的连接请求</p></blockquote></li><li><strong>第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（<code>SYN = 1</code>），并且指定自己的初始化序列号 <code>ISN(y)</code>，即图中的 <code>seq = y</code>。同时会把客户端的 <code>ISN + 1</code> 作为确认号 <code>ack</code> 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 <code>x + 1</code>，此时服务器处于 <code>SYN_REVD</code> 的状态。 <blockquote><p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p></blockquote></li><li><strong>第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 <code>ACK</code> 报文，也是一样把服务器的 <code>ISN + 1</code> 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 <code>y + 1</code>，并指明此时客户端的序列号 <code>seq = x + 1</code>（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。 <blockquote><p><code>ESTABLISHED</code>：代表一个打开的连接，数据可以传送给用户</p></blockquote></li><li>服务器收到 ACK 报文之后，也处于 Establised 状态，至此，双方建立起了 TCP 连接。可以进行数据传输了</li></ol><h3 id="为什么要三次握手" tabindex="-1">为什么要三次握手？ <a class="header-anchor" href="#为什么要三次握手" aria-label="Permalink to &quot;为什么要三次握手？&quot;">​</a></h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p><ul><li>第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常</li><li>第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）： <ul><li>客户端确认了：自己发送、接收正常，对方发送、接收正常；</li><li>服务器确认了：对方发送正常，自己接收正常</li></ul></li><li>第三次握手（客户端发送 ACK 报文给服务器）： <ul><li>客户端确认了：自己发送、接收正常，对方发送、接收正常；</li><li>服务器确认了：自己发送、接收正常，对方发送、接收正常</li></ul></li></ul><h3 id="三次握手过程中可以携带数据吗" tabindex="-1">三次握手过程中可以携带数据吗？ <a class="header-anchor" href="#三次握手过程中可以携带数据吗" aria-label="Permalink to &quot;三次握手过程中可以携带数据吗？&quot;">​</a></h3><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong>。</p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后<strong>疯狂重复发 SYN 报文</strong>的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。</p><blockquote><p>简单的记忆就是，请求连接/接收 即 SYN = 1 的时候不能携带数据</p></blockquote><h3 id="syn-洪泛攻击" tabindex="-1">SYN 洪泛攻击 <a class="header-anchor" href="#syn-洪泛攻击" aria-label="Permalink to &quot;SYN 洪泛攻击&quot;">​</a></h3><p>SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内<strong>伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN</strong>。对于服务端而言，会产生两个危险的后果:</p><ul><li>处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</li><li>由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</li></ul><h3 id="如果第三次握手丢失了-客户端服务端会如何处理" tabindex="-1">如果第三次握手丢失了，客户端服务端会如何处理 <a class="header-anchor" href="#如果第三次握手丢失了-客户端服务端会如何处理" aria-label="Permalink to &quot;如果第三次握手丢失了，客户端服务端会如何处理&quot;">​</a></h3><p>服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><p>四次挥手，关闭连接过程如下：</p><img src="'+t+'" width="70%/"><p>上图中符号的意思：</p><ul><li>FIN ：连接终止位</li><li>seq：发送的第一个字节的序号</li><li>ACK：确认报文段</li><li>ack：确认号。希望收到的下一个数据的第一个字节的序号</li></ul><p>刚开始双方都处于ESTABLISHED 状态，假设是客户端先发起关闭请求。过程如下：</p><ol><li><p><strong>第一次挥手</strong>：客户端发送一个 <code>FIN</code> 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并停止再发送数据，主动关闭 TCP 连接。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p><blockquote><p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote></li><li><p><strong>第二次挥手</strong>：服务端收到 FIN 之后，会发送 <code>ACK</code> 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p><blockquote><p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p></blockquote><p>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的<strong>连接释放报文段</strong>。</p><blockquote><p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p></blockquote></li><li><p><strong>第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。</p><blockquote><p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote></li><li><p><strong>第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 TIME_WAIT （时间等待）状态。</p><blockquote><p><code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><p>PS:注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。</p></li></ol><h3 id="等待2msl的意义" tabindex="-1">等待2MSL的意义 <a class="header-anchor" href="#等待2msl的意义" aria-label="Permalink to &quot;等待2MSL的意义&quot;">​</a></h3><p>如果不等待会怎样？</p><p>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。</p><p>那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?</p><ul><li>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</li><li>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</li></ul><p>这就是等待 2MSL 的意义。</p><h3 id="为什么是4次挥手" tabindex="-1">为什么是4次挥手 <a class="header-anchor" href="#为什么是4次挥手" aria-label="Permalink to &quot;为什么是4次挥手&quot;">​</a></h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p><h1 id="dns解析-域名解析" tabindex="-1">DNS解析，域名解析 <a class="header-anchor" href="#dns解析-域名解析" aria-label="Permalink to &quot;DNS解析，域名解析&quot;">​</a></h1><img src="'+r+'" width="60%/"><ol><li>浏览器首先查看查找本地<code>hosts文件</code>（将一些常用的网址域名与其对应的IP地址建立一个关联数据库），如果有则返回，否则进行下一步。</li><li>浏览器查看<code>本地缓存</code>，是否存在本条目的缓存，如果有则直接返回，否则进行下一步。</li><li>将请求转发给<code>本地域名服务器</code>LDNS来解析这个域名。在本地域名服务器上查看域名 是否本地解析，是则本地解析返回，否则在<code>本地DNS服务器的缓存</code>中查找，有则返回，无则进行下一步</li><li>向全球13个<code>根域服务器发</code>起DNS请求，</li><li>根域名服务器返回给本地域名服务器LDNS一个所查询域的<code>主域名服务器</code>（（gTLD Server，国际顶尖域名服务器，如.com .cn .org等））地址</li><li>此时本地域名服务器LDNS再发送DNS请求给<code>主域名服务器gTLD</code></li><li>接受请求的gTLD查找并返回这个域名对应的<code>Name Server</code>（网站注册的域名服务器）的地址给本地域名服务器，这个Name Server就是网站注册的域名服务器</li><li>本地域名服务器再向这个<code>网站注册的域名服务器</code>发送DNS请求，Name Server根据映射关系表找到目标ip，返回给本地域名服务器LDNS</li><li>LDNS<code>缓存</code>这个域名和对应的ip</li><li>LDNS把解析的结果返回给<code>浏览器</code>，浏览器并缓存到本地系统缓存中，域名解析过程至此结束</li></ol>',49),p=[s];function n(S,h,u,N,_,q){return o(),l("div",null,p)}const b=e(d,[["render",n]]);export{T as __pageData,b as default};
